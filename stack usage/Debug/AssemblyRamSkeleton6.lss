
AssemblyRamSkeleton6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004c  00800200  00000e00  00000e94  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e00  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000124  0080024c  0080024c  00000ee0  2**0
                  ALLOC
  3 .stab         00000768  00000000  00000000  00000ee0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000000e7  00000000  00000000  00001648  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000188  00000000  00000000  00001730  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000fee  00000000  00000000  000018b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000550  00000000  00000000  000028a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000977  00000000  00000000  00002df6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000031c  00000000  00000000  00003770  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005ba  00000000  00000000  00003a8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000a51  00000000  00000000  00004046  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  00004a97  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 37 01 	jmp	0x26e	; 0x26e <__ctors_end>
   4:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
   8:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
   c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  10:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  14:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  18:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  1c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  20:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  24:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  28:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  2c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  30:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  34:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  38:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  3c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  40:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  44:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  48:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  4c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  50:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  54:	0c 94 7e 01 	jmp	0x2fc	; 0x2fc <__vector_21>
  58:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  5c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  60:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  64:	0c 94 68 05 	jmp	0xad0	; 0xad0 <__vector_25>
  68:	0c 94 1d 05 	jmp	0xa3a	; 0xa3a <__vector_26>
  6c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  70:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  74:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  78:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  7c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  80:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  84:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  88:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  8c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  90:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  94:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  98:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  9c:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  a0:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  a4:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  a8:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  ac:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  b0:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  b4:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  b8:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  bc:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  c0:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  c4:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  c8:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  cc:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  d0:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  d4:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  d8:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  dc:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>
  e0:	0c 94 62 01 	jmp	0x2c4	; 0x2c4 <__bad_interrupt>

000000e4 <__c.1738>:
  e4:	0a 0d 00                                            ...

000000e7 <__c.1741>:
  e7:	20 20 45 72 72 6f 72 20 3d 20 00                      Error = .

000000f2 <__c.1743>:
  f2:	0a 0d 00                                            ...

000000f5 <__c.1745>:
  f5:	53 74 61 63 6b 20 42 79 74 65 20 43 6f 75 6e 74     Stack Byte Count
 105:	20 3d 20 00                                          = .

00000109 <__c.1747>:
 109:	0a 0d 00                                            ...

0000010c <__c.1751>:
 10c:	20 20 41 64 64 72 65 73 73 20 6f 75 74 20 6f 66       Address out of
 11c:	20 72 61 6e 67 65 0a 0d 00                           range...

00000125 <__c.1753>:
 125:	20 20 4c 65 6e 67 74 68 20 69 6e 20 68 65 78 20       Length in hex 
 135:	28 6d 61 78 20 34 30 29 20 3d 20 00                 (max 40) = .

00000141 <__c.1755>:
 141:	20 20 56 61 6c 75 65 20 28 69 6e 20 68 65 78 29       Value (in hex)
 151:	20 3d 20 00                                          = .

00000155 <__c.1758>:
 155:	20 20 4d 65 6d 6f 72 79 20 3d 00                      Memory =.

00000160 <__c.1760>:
 160:	0a 0d 20 20 00                                      ..  .

00000165 <__c.1765>:
 165:	0a 0d 00                                            ...

00000168 <__c.1767>:
 168:	49 6e 76 61 6c 69 64 20 76 61 6c 75 65 0a 0d 00     Invalid value...

00000178 <__c.1769>:
 178:	57 72 69 74 65 20 4d 65 6d 0a 0d 00                 Write Mem...

00000184 <__c.1771>:
 184:	0a 0d 00                                            ...

00000187 <__c.1774>:
 187:	63 6d 64 3e 20 00                                   cmd> .

0000018d <__c.1779>:
 18d:	20 20 43 6f 6d 6d 61 6e 64 73 20 61 72 65 3a 0a       Commands are:.
 19d:	0d 00                                               ..

0000019f <__c.1781>:
 19f:	20 20 67 65 20 20 2d 20 44 69 73 70 6c 61 79 20       ge  - Display 
 1af:	65 72 72 6f 72 20 63 6f 64 65 0a 0d 00              error code...

000001bc <__c.1783>:
 1bc:	20 20 63 65 20 20 2d 20 43 6c 65 61 72 20 63 75       ce  - Clear cu
 1cc:	72 72 65 6e 74 20 65 72 72 6f 72 0a 0d 00           rrent error...

000001da <__c.1785>:
 1da:	20 20 73 6b 20 20 2d 20 73 74 61 63 6b 20 75 73       sk  - stack us
 1ea:	65 64 0a 0d 00                                      ed...

000001ef <__c.1787>:
 1ef:	20 20 72 6d 20 20 2d 20 52 65 61 64 20 6d 65 6d       rm  - Read mem
 1ff:	6f 72 79 0a 0d 00                                   ory...

00000205 <__c.1789>:
 205:	20 20 77 6d 20 20 2d 20 57 72 69 74 65 20 6d 65       wm  - Write me
 215:	6d 6f 72 79 0a 0d 00                                mory...

0000021c <__c.1791>:
 21c:	20 20 3f 20 20 20 2d 20 44 69 73 70 6c 61 79 20       ?   - Display 
 22c:	74 68 69 73 20 68 65 6c 70 20 6d 65 6e 75 0a 0d     this help menu..
	...

0000023d <__c.1481>:
 23d:	57 65 6c 63 6f 6d 65 20 74 6f 20 45 6d 62 65 64     Welcome to Embed
 24d:	64 65 64 20 53 79 73 74 65 6d 73 20 50 72 6f 67     ded Systems Prog
 25d:	72 61 6d 6d 69 6e 67 0a 0d 00                       ramming...

00000267 <__c.1483>:
 267:	63 6d 64 3e 20 00 00                                cmd> ..

0000026e <__ctors_end>:
 26e:	11 24       	eor	r1, r1
 270:	1f be       	out	0x3f, r1	; 63
 272:	cf ef       	ldi	r28, 0xFF	; 255
 274:	d1 e2       	ldi	r29, 0x21	; 33
 276:	de bf       	out	0x3e, r29	; 62
 278:	cd bf       	out	0x3d, r28	; 61
 27a:	00 e0       	ldi	r16, 0x00	; 0
 27c:	0c bf       	out	0x3c, r16	; 60
;    before the data and bss initialization.
; 2. Fill the RAM, from 0x200 to 0x21FF, with 0xAA.

.section .init4,"ax",@progbits ; set memory section to execute before main

		ldi r17,0xAA ; load 0xAA into a register so it can be copied to RAM
 27e:	1a ea       	ldi	r17, 0xAA	; 170
		ldi r28,0xFF ; Set register Y to point to top of RAM 0x21FF. Set Y low byte
 280:	cf ef       	ldi	r28, 0xFF	; 255
		ldi r29,0x21 ; Set Y high byte
 282:	d1 e2       	ldi	r29, 0x21	; 33
		clr r26		 ; Clear X low byte
 284:	aa 27       	eor	r26, r26
		ldi r27,0x02 ; Set X high byte to point to bottom of RAM 0x200
 286:	b2 e0       	ldi	r27, 0x02	; 2

00000288 <loop>:
loop:	st X+,r17    ; Store 0xAA into mem address in RAM specified by X. Post increment X
 288:	1d 93       	st	X+, r17
		cp r27,r29   ; Compare high byte of X with high byte of Y
 28a:	bd 17       	cp	r27, r29
		brne loop    ; If X high byte and Y high byte not equal jump back to loop:
 28c:	e9 f7       	brne	.-6      	; 0x288 <loop>
		cp r26,r28   ; Compare low byte of X with low byte of Y
 28e:	ac 17       	cp	r26, r28
		brne loop    ; If X high byte and Y high byte not equal jump back to loop:
 290:	d9 f7       	brne	.-10     	; 0x288 <loop>

00000292 <__do_copy_data>:
 292:	12 e0       	ldi	r17, 0x02	; 2
 294:	a0 e0       	ldi	r26, 0x00	; 0
 296:	b2 e0       	ldi	r27, 0x02	; 2
 298:	e0 e0       	ldi	r30, 0x00	; 0
 29a:	fe e0       	ldi	r31, 0x0E	; 14
 29c:	00 e0       	ldi	r16, 0x00	; 0
 29e:	0b bf       	out	0x3b, r16	; 59
 2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <__do_copy_data+0x14>
 2a2:	07 90       	elpm	r0, Z+
 2a4:	0d 92       	st	X+, r0
 2a6:	ac 34       	cpi	r26, 0x4C	; 76
 2a8:	b1 07       	cpc	r27, r17
 2aa:	d9 f7       	brne	.-10     	; 0x2a2 <__do_copy_data+0x10>

000002ac <__do_clear_bss>:
 2ac:	13 e0       	ldi	r17, 0x03	; 3
 2ae:	ac e4       	ldi	r26, 0x4C	; 76
 2b0:	b2 e0       	ldi	r27, 0x02	; 2
 2b2:	01 c0       	rjmp	.+2      	; 0x2b6 <.do_clear_bss_start>

000002b4 <.do_clear_bss_loop>:
 2b4:	1d 92       	st	X+, r1

000002b6 <.do_clear_bss_start>:
 2b6:	a0 37       	cpi	r26, 0x70	; 112
 2b8:	b1 07       	cpc	r27, r17
 2ba:	e1 f7       	brne	.-8      	; 0x2b4 <.do_clear_bss_loop>
 2bc:	0e 94 c2 06 	call	0xd84	; 0xd84 <main>
 2c0:	0c 94 fe 06 	jmp	0xdfc	; 0xdfc <_exit>

000002c4 <__bad_interrupt>:
 2c4:	0c 94 d6 01 	jmp	0x3ac	; 0x3ac <__vector_default>

000002c8 <ReportError>:
 * Error handler
 *****************************************************************************/
void ReportError(eErrorType iError)
{
	// Only allow 1 error to be logged at one time
	if (SystemError == NO_ERROR)
 2c8:	90 91 4c 02 	lds	r25, 0x024C
 2cc:	99 23       	and	r25, r25
 2ce:	19 f4       	brne	.+6      	; 0x2d6 <ReportError+0xe>
	{    /* Record error and set error LED */
		SystemError = iError;
 2d0:	80 93 4c 02 	sts	0x024C, r24
		CLEAR_BIT(PORTB, ERROR_LED_BIT);
 2d4:	29 98       	cbi	0x05, 1	; 5
 2d6:	08 95       	ret

000002d8 <ClearError>:
}

void ClearError(void)
{
	/* Record error and set error LED */
	SystemError = NO_ERROR;
 2d8:	10 92 4c 02 	sts	0x024C, r1
	SET_BIT(PORTB, ERROR_LED_BIT);
 2dc:	29 9a       	sbi	0x05, 1	; 5
}
 2de:	08 95       	ret

000002e0 <GetError>:

eErrorType GetError(void)
{
	/* Record error and set error LED */
	return SystemError;
}
 2e0:	80 91 4c 02 	lds	r24, 0x024C
 2e4:	08 95       	ret

000002e6 <ISR_InitTimer0>:
	 *     3: unused = 0  
	 *     2: unused = 0
	 *     1: WGM01  = 1  Sets Waveform Generation mode to CTC
	 *     0: WGM00  = 0
	 */
	TCCR0A  = _BV(WGM01);
 2e6:	82 e0       	ldi	r24, 0x02	; 2
 2e8:	84 bd       	out	0x24, r24	; 36
	 *     3: WGM02  = 0  Sets Waveform Generation mode to CTC
	 *     2: CS02   = 1  Sets prescaler to 1024, I/O clock
	 *     1: CS01   = 0
	 *     0: CS00   = 1
	 */
	TCCR0B = _BV(CS02) | _BV(CS00);
 2ea:	95 e0       	ldi	r25, 0x05	; 5
 2ec:	95 bd       	out	0x25, r25	; 37
   
	// Load Compare values for timer 0
	OCR0A = TIMER0_CNT;
 2ee:	93 ec       	ldi	r25, 0xC3	; 195
 2f0:	97 bd       	out	0x27, r25	; 39
	OCR0B = 0;		// not using this feature
 2f2:	18 bc       	out	0x28, r1	; 40
	 * Bit(s) 7-3: Unused = 0
	 *          2: OCIE0B = 0  Disable timer compare interrupt B
	 *          1: OCIE0A = 1  Enable timer compare interrupt A
	 *          0: TOIE0  = 0  Disable overflow interrupt
     */
	TIMSK0 = _BV(OCIE0A);
 2f4:	80 93 6e 00 	sts	0x006E, r24

	// Optional: Initialize timer to 0
	TCNT0 = 0;
 2f8:	16 bc       	out	0x26, r1	; 38
}
 2fa:	08 95       	ret

000002fc <__vector_21>:
 *****************************************************************************/
/* 
 * This is the ISR that handles Timer 0 Compare interrupts.
 */
ISR(TIMER0_COMPA_vect)
{
 2fc:	1f 92       	push	r1
 2fe:	0f 92       	push	r0
 300:	0f b6       	in	r0, 0x3f	; 63
 302:	0f 92       	push	r0
 304:	0b b6       	in	r0, 0x3b	; 59
 306:	0f 92       	push	r0
 308:	11 24       	eor	r1, r1
 30a:	2f 93       	push	r18
 30c:	3f 93       	push	r19
 30e:	4f 93       	push	r20
 310:	5f 93       	push	r21
 312:	6f 93       	push	r22
 314:	7f 93       	push	r23
 316:	8f 93       	push	r24
 318:	9f 93       	push	r25
 31a:	af 93       	push	r26
 31c:	bf 93       	push	r27
 31e:	ef 93       	push	r30
 320:	ff 93       	push	r31
	static unsigned int uiMedThreadCount = 1;		
	static eBooleanType bMedThreadInProgress = FALSE;

	// Check for overrun. 
	if (bMedThreadInProgress == TRUE)
 322:	80 91 4d 02 	lds	r24, 0x024D
 326:	81 30       	cpi	r24, 0x01	; 1
 328:	21 f4       	brne	.+8      	; 0x332 <__vector_21+0x36>
	{	/* Haven't finished previous time through
		 * Set error, and don't do any more tasks. Just return. */
		ReportError(MEDIUM_TASK_OVERRUN);
 32a:	82 e0       	ldi	r24, 0x02	; 2
 32c:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
 330:	2a c0       	rjmp	.+84     	; 0x386 <__vector_21+0x8a>
	}
	else
	{   // No overrun. Continue tasks
		bMedThreadInProgress = TRUE;
 332:	81 e0       	ldi	r24, 0x01	; 1
 334:	80 93 4d 02 	sts	0x024D, r24

	/**************************************************************************
	 * Update medium-thread main timer
	 **************************************************************************/
		if (uiMedThreadCount >= (unsigned int)
 338:	80 91 00 02 	lds	r24, 0x0200
 33c:	90 91 01 02 	lds	r25, 0x0201
 340:	88 3c       	cpi	r24, 0xC8	; 200
 342:	91 05       	cpc	r25, r1
 344:	18 f0       	brcs	.+6      	; 0x34c <__vector_21+0x50>
			(MAX_MEDIUM_THREAD_TIME/TIMER0_TIME))
		{	/* Reset the interrupt counter */
			uiMedThreadCount = 1;
 346:	81 e0       	ldi	r24, 0x01	; 1
 348:	90 e0       	ldi	r25, 0x00	; 0
 34a:	01 c0       	rjmp	.+2      	; 0x34e <__vector_21+0x52>
		}
		else
		{
			++uiMedThreadCount;
 34c:	01 96       	adiw	r24, 0x01	; 1
 34e:	90 93 01 02 	sts	0x0201, r25
 352:	80 93 00 02 	sts	0x0200, r24
		}

	/**************************************************************************
	 * Call the Medium thread tasks, when it's time
	 **************************************************************************/    
       if ((uiMedThreadCount % (unsigned int) 
 356:	80 91 00 02 	lds	r24, 0x0200
 35a:	90 91 01 02 	lds	r25, 0x0201
 35e:	64 e1       	ldi	r22, 0x14	; 20
 360:	70 e0       	ldi	r23, 0x00	; 0
 362:	0e 94 ce 06 	call	0xd9c	; 0xd9c <__udivmodhi4>
 366:	00 97       	sbiw	r24, 0x00	; 0
 368:	11 f4       	brne	.+4      	; 0x36e <__vector_21+0x72>
             (HEARTBEAT_TIME/TIMER0_TIME)) == 0)
        {
            // Toggle the heartbeat LED
            heartbeat();
 36a:	0e 94 eb 02 	call	0x5d6	; 0x5d6 <heartbeat>
        }
        
        if ((uiMedThreadCount % (unsigned int) 
 36e:	80 91 00 02 	lds	r24, 0x0200
 372:	90 91 01 02 	lds	r25, 0x0201
 376:	83 70       	andi	r24, 0x03	; 3
 378:	90 70       	andi	r25, 0x00	; 0
 37a:	00 97       	sbiw	r24, 0x00	; 0
 37c:	11 f4       	brne	.+4      	; 0x382 <__vector_21+0x86>
             (MENU_TIME/TIMER0_TIME)) == 0)
        {
            // Toggle the heartbeat LED
            RunMenu();
 37e:	0e 94 0f 03 	call	0x61e	; 0x61e <RunMenu>
        }
        // Clear in-progress flag
        bMedThreadInProgress = FALSE;
 382:	10 92 4d 02 	sts	0x024D, r1
    }   // End of medium thread tasks
}
 386:	ff 91       	pop	r31
 388:	ef 91       	pop	r30
 38a:	bf 91       	pop	r27
 38c:	af 91       	pop	r26
 38e:	9f 91       	pop	r25
 390:	8f 91       	pop	r24
 392:	7f 91       	pop	r23
 394:	6f 91       	pop	r22
 396:	5f 91       	pop	r21
 398:	4f 91       	pop	r20
 39a:	3f 91       	pop	r19
 39c:	2f 91       	pop	r18
 39e:	0f 90       	pop	r0
 3a0:	0b be       	out	0x3b, r0	; 59
 3a2:	0f 90       	pop	r0
 3a4:	0f be       	out	0x3f, r0	; 63
 3a6:	0f 90       	pop	r0
 3a8:	1f 90       	pop	r1
 3aa:	18 95       	reti

000003ac <__vector_default>:
/* This handler takes care of all unused interrupts
 */
ISR(__vector_default)
{
 3ac:	1f 92       	push	r1
 3ae:	0f 92       	push	r0
 3b0:	0f b6       	in	r0, 0x3f	; 63
 3b2:	0f 92       	push	r0
 3b4:	0b b6       	in	r0, 0x3b	; 59
 3b6:	0f 92       	push	r0
 3b8:	11 24       	eor	r1, r1
 3ba:	2f 93       	push	r18
 3bc:	3f 93       	push	r19
 3be:	4f 93       	push	r20
 3c0:	5f 93       	push	r21
 3c2:	6f 93       	push	r22
 3c4:	7f 93       	push	r23
 3c6:	8f 93       	push	r24
 3c8:	9f 93       	push	r25
 3ca:	af 93       	push	r26
 3cc:	bf 93       	push	r27
 3ce:	ef 93       	push	r30
 3d0:	ff 93       	push	r31
	ReportError(UNUSED_INTERRUPT);
 3d2:	8e e0       	ldi	r24, 0x0E	; 14
 3d4:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
}
 3d8:	ff 91       	pop	r31
 3da:	ef 91       	pop	r30
 3dc:	bf 91       	pop	r27
 3de:	af 91       	pop	r26
 3e0:	9f 91       	pop	r25
 3e2:	8f 91       	pop	r24
 3e4:	7f 91       	pop	r23
 3e6:	6f 91       	pop	r22
 3e8:	5f 91       	pop	r21
 3ea:	4f 91       	pop	r20
 3ec:	3f 91       	pop	r19
 3ee:	2f 91       	pop	r18
 3f0:	0f 90       	pop	r0
 3f2:	0b be       	out	0x3b, r0	; 59
 3f4:	0f 90       	pop	r0
 3f6:	0f be       	out	0x3f, r0	; 63
 3f8:	0f 90       	pop	r0
 3fa:	1f 90       	pop	r1
 3fc:	18 95       	reti

000003fe <_itoa>:
/******************************************************************************
 * Converts the passed integer to its equivalent ASCII string, using the
 * specified base. The allowable base is only 10 or 16.
 ******************************************************************************/
void _itoa(char **buf, int i, int base)
{
 3fe:	ef 92       	push	r14
 400:	ff 92       	push	r15
 402:	0f 93       	push	r16
 404:	1f 93       	push	r17
 406:	cf 93       	push	r28
 408:	df 93       	push	r29
 40a:	cd b7       	in	r28, 0x3d	; 61
 40c:	de b7       	in	r29, 0x3e	; 62
 40e:	65 97       	sbiw	r28, 0x15	; 21
 410:	0f b6       	in	r0, 0x3f	; 63
 412:	f8 94       	cli
 414:	de bf       	out	0x3e, r29	; 62
 416:	0f be       	out	0x3f, r0	; 63
 418:	cd bf       	out	0x3d, r28	; 61
 41a:	8c 01       	movw	r16, r24
 41c:	9b 01       	movw	r18, r22
 41e:	7a 01       	movw	r14, r20
    char *s;
    int rem;
    char rev[STRLEN+1];

    if (i == 0)
 420:	61 15       	cp	r22, r1
 422:	71 05       	cpc	r23, r1
 424:	59 f4       	brne	.+22     	; 0x43c <_itoa+0x3e>
    { /* Converting a 0, so we just generate the return string */
        (*buf)[0] = '0';
 426:	dc 01       	movw	r26, r24
 428:	ed 91       	ld	r30, X+
 42a:	fc 91       	ld	r31, X
 42c:	11 97       	sbiw	r26, 0x01	; 1
 42e:	80 e3       	ldi	r24, 0x30	; 48
 430:	80 83       	st	Z, r24
        (*buf)[1] = '\0';   /* RJW: Null-terminate string */
 432:	ed 91       	ld	r30, X+
 434:	fc 91       	ld	r31, X
 436:	11 97       	sbiw	r26, 0x01	; 1
 438:	11 82       	std	Z+1, r1	; 0x01
        return;
 43a:	46 c0       	rjmp	.+140    	; 0x4c8 <_itoa+0xca>
	/*
	 * If the number to be converted is negative, we'll just treat it as
	 * positive, add a minus sign to the output string, then perform the
	 * conversion,
	 */
	if (i < 0)
 43c:	77 ff       	sbrs	r23, 7
 43e:	0f c0       	rjmp	.+30     	; 0x45e <_itoa+0x60>
	{
		i = -i;
 440:	30 95       	com	r19
 442:	21 95       	neg	r18
 444:	3f 4f       	sbci	r19, 0xFF	; 255
		(*buf)[0] = '-';
 446:	dc 01       	movw	r26, r24
 448:	ed 91       	ld	r30, X+
 44a:	fc 91       	ld	r31, X
 44c:	11 97       	sbiw	r26, 0x01	; 1
 44e:	8d e2       	ldi	r24, 0x2D	; 45
 450:	80 83       	st	Z, r24
		++(*buf);
 452:	8d 91       	ld	r24, X+
 454:	9c 91       	ld	r25, X
 456:	11 97       	sbiw	r26, 0x01	; 1
 458:	01 96       	adiw	r24, 0x01	; 1
 45a:	8d 93       	st	X+, r24
 45c:	9c 93       	st	X, r25
	} 

    /* Set "rev" array to 0 */
    memset((MEMPTR)rev,0,STRLEN+1);
 45e:	fe 01       	movw	r30, r28
 460:	31 96       	adiw	r30, 0x01	; 1
 462:	85 e1       	ldi	r24, 0x15	; 21
 464:	df 01       	movw	r26, r30
 466:	1d 92       	st	X+, r1
 468:	8a 95       	dec	r24
 46a:	e9 f7       	brne	.-6      	; 0x466 <_itoa+0x68>

    /* Initialize first location in "reverse" array to 0 */
    rev[STRLEN] = 0;
    s = &rev[STRLEN];     /* Will access reverse array by pointer "s" */
 46c:	fe 01       	movw	r30, r28
 46e:	75 96       	adiw	r30, 0x15	; 21
     * End result is a string that consists of ASCII version of the input
     * number. 
	 */
    while (i)     /* Continue until i == NULL */
    {
        rem = i % base;     /* Get character for this position in string */
 470:	c9 01       	movw	r24, r18
 472:	b7 01       	movw	r22, r14
 474:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <__divmodhi4>
        if (rem < 10)
 478:	8a 30       	cpi	r24, 0x0A	; 10
 47a:	91 05       	cpc	r25, r1
 47c:	14 f4       	brge	.+4      	; 0x482 <_itoa+0x84>
        {
            *--s = rem + '0';           /* Convert to ASCII */
 47e:	80 5d       	subi	r24, 0xD0	; 208
 480:	08 c0       	rjmp	.+16     	; 0x492 <_itoa+0x94>
        }
        else if (base == 16)
 482:	b0 e1       	ldi	r27, 0x10	; 16
 484:	eb 16       	cp	r14, r27
 486:	f1 04       	cpc	r15, r1
 488:	29 f4       	brne	.+10     	; 0x494 <_itoa+0x96>
        {
            *--s = "abcdef"[rem - 10];  /* Convert to ASCII */
 48a:	88 50       	subi	r24, 0x08	; 8
 48c:	9e 4f       	sbci	r25, 0xFE	; 254
 48e:	dc 01       	movw	r26, r24
 490:	8c 91       	ld	r24, X
 492:	82 93       	st	-Z, r24
        }
        i /= base;
 494:	c9 01       	movw	r24, r18
 496:	b7 01       	movw	r22, r14
 498:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <__divmodhi4>
 49c:	9b 01       	movw	r18, r22
     * The quotient is the term for the next division.
     *
     * End result is a string that consists of ASCII version of the input
     * number. 
	 */
    while (i)     /* Continue until i == NULL */
 49e:	61 15       	cp	r22, r1
 4a0:	71 05       	cpc	r23, r1
 4a2:	31 f7       	brne	.-52     	; 0x470 <_itoa+0x72>
 4a4:	9f 01       	movw	r18, r30
 4a6:	07 c0       	rjmp	.+14     	; 0x4b6 <_itoa+0xb8>
	 * If the original number was negative, a minus sign has already
     * been appended.  Last, append a NULL.
	 */
    while (*s)
    {
        (*buf)[0] = *s++;
 4a8:	8c 93       	st	X, r24
        ++(*buf);
 4aa:	f8 01       	movw	r30, r16
 4ac:	80 81       	ld	r24, Z
 4ae:	91 81       	ldd	r25, Z+1	; 0x01
 4b0:	01 96       	adiw	r24, 0x01	; 1
 4b2:	91 83       	std	Z+1, r25	; 0x01
 4b4:	80 83       	st	Z, r24
    /*
	 * Copy string in "rev" to string that will be returned.
	 * If the original number was negative, a minus sign has already
     * been appended.  Last, append a NULL.
	 */
    while (*s)
 4b6:	d9 01       	movw	r26, r18
 4b8:	8d 91       	ld	r24, X+
 4ba:	9d 01       	movw	r18, r26
 4bc:	f8 01       	movw	r30, r16
 4be:	a0 81       	ld	r26, Z
 4c0:	b1 81       	ldd	r27, Z+1	; 0x01
 4c2:	88 23       	and	r24, r24
 4c4:	89 f7       	brne	.-30     	; 0x4a8 <_itoa+0xaa>
    {
        (*buf)[0] = *s++;
        ++(*buf);
    }
    (*buf)[0] = '\0';
 4c6:	1c 92       	st	X, r1
}
 4c8:	65 96       	adiw	r28, 0x15	; 21
 4ca:	0f b6       	in	r0, 0x3f	; 63
 4cc:	f8 94       	cli
 4ce:	de bf       	out	0x3e, r29	; 62
 4d0:	0f be       	out	0x3f, r0	; 63
 4d2:	cd bf       	out	0x3d, r28	; 61
 4d4:	df 91       	pop	r29
 4d6:	cf 91       	pop	r28
 4d8:	1f 91       	pop	r17
 4da:	0f 91       	pop	r16
 4dc:	ff 90       	pop	r15
 4de:	ef 90       	pop	r14
 4e0:	08 95       	ret

000004e2 <_atoi>:
 * I use an "if" statement to check if it's "10" or "16". Hence, only those
 * values for base can be used. (Note: This is an issue with an old compiler
 * on 68HC11. Not verified to still be a problem here).
 ******************************************************************************/
int _atoi(char *buf, int base)
{
 4e2:	af 92       	push	r10
 4e4:	bf 92       	push	r11
 4e6:	df 92       	push	r13
 4e8:	ef 92       	push	r14
 4ea:	ff 92       	push	r15
 4ec:	0f 93       	push	r16
 4ee:	1f 93       	push	r17
 4f0:	cf 93       	push	r28
 4f2:	df 93       	push	r29
 4f4:	fc 01       	movw	r30, r24
 4f6:	7b 01       	movw	r14, r22
	int i;
    int power = 1;
	char dummy;
	eBooleanType negNum = FALSE;

    StrLength = strlen(buf);
 4f8:	ec 01       	movw	r28, r24
 4fa:	09 90       	ld	r0, Y+
 4fc:	00 20       	and	r0, r0
 4fe:	e9 f7       	brne	.-6      	; 0x4fa <_atoi+0x18>
 500:	21 97       	sbiw	r28, 0x01	; 1
 502:	c8 1b       	sub	r28, r24
 504:	d9 0b       	sbc	r29, r25
	/*
	 * First, test the leading character for a minus sign.  If present,
	 * strip it off but set a flag so we will remember to return a 
	 * negative result.
	 */
	if (*buf == '-')
 506:	80 81       	ld	r24, Z
 508:	8d 32       	cpi	r24, 0x2D	; 45
 50a:	29 f4       	brne	.+10     	; 0x516 <_atoi+0x34>
	{
		dummy = *buf++;		// this is simply to avoid a compiler warning.
 50c:	31 96       	adiw	r30, 0x01	; 1
		negNum = TRUE;
		StrLength--;
 50e:	21 97       	sbiw	r28, 0x01	; 1
	 * negative result.
	 */
	if (*buf == '-')
	{
		dummy = *buf++;		// this is simply to avoid a compiler warning.
		negNum = TRUE;
 510:	dd 24       	eor	r13, r13
 512:	d3 94       	inc	r13
 514:	01 c0       	rjmp	.+2      	; 0x518 <_atoi+0x36>
	int StrVal = 0;
	int StrLength;
	int i;
    int power = 1;
	char dummy;
	eBooleanType negNum = FALSE;
 516:	dd 24       	eor	r13, r13
int _atoi(char *buf, int base)
{
	int StrVal = 0;
	int StrLength;
	int i;
    int power = 1;
 518:	61 e0       	ldi	r22, 0x01	; 1
 51a:	70 e0       	ldi	r23, 0x00	; 0
		negNum = TRUE;
		StrLength--;
	}

    // Calculate power of base for first digit
    for (i = 0; i < StrLength - 1; ++i)
 51c:	40 e0       	ldi	r20, 0x00	; 0
 51e:	50 e0       	ldi	r21, 0x00	; 0
 520:	9e 01       	movw	r18, r28
 522:	21 50       	subi	r18, 0x01	; 1
 524:	30 40       	sbci	r19, 0x00	; 0
 526:	1a c0       	rjmp	.+52     	; 0x55c <_atoi+0x7a>
    {
        if (base == 10)
 528:	8a e0       	ldi	r24, 0x0A	; 10
 52a:	e8 16       	cp	r14, r24
 52c:	f1 04       	cpc	r15, r1
 52e:	59 f4       	brne	.+22     	; 0x546 <_atoi+0x64>
        {
            power *= 10;
 530:	cb 01       	movw	r24, r22
 532:	88 0f       	add	r24, r24
 534:	99 1f       	adc	r25, r25
 536:	b3 e0       	ldi	r27, 0x03	; 3
 538:	66 0f       	add	r22, r22
 53a:	77 1f       	adc	r23, r23
 53c:	ba 95       	dec	r27
 53e:	e1 f7       	brne	.-8      	; 0x538 <_atoi+0x56>
 540:	68 0f       	add	r22, r24
 542:	79 1f       	adc	r23, r25
 544:	09 c0       	rjmp	.+18     	; 0x558 <_atoi+0x76>
        }

        if (base == 16)
 546:	a0 e1       	ldi	r26, 0x10	; 16
 548:	ea 16       	cp	r14, r26
 54a:	f1 04       	cpc	r15, r1
 54c:	29 f4       	brne	.+10     	; 0x558 <_atoi+0x76>
        {
            power *= 16;
 54e:	84 e0       	ldi	r24, 0x04	; 4
 550:	66 0f       	add	r22, r22
 552:	77 1f       	adc	r23, r23
 554:	8a 95       	dec	r24
 556:	e1 f7       	brne	.-8      	; 0x550 <_atoi+0x6e>
		negNum = TRUE;
		StrLength--;
	}

    // Calculate power of base for first digit
    for (i = 0; i < StrLength - 1; ++i)
 558:	4f 5f       	subi	r20, 0xFF	; 255
 55a:	5f 4f       	sbci	r21, 0xFF	; 255
 55c:	42 17       	cp	r20, r18
 55e:	53 07       	cpc	r21, r19
 560:	1c f3       	brlt	.-58     	; 0x528 <_atoi+0x46>
 562:	5f 01       	movw	r10, r30
 564:	00 e0       	ldi	r16, 0x00	; 0
 566:	10 e0       	ldi	r17, 0x00	; 0
 568:	e0 e0       	ldi	r30, 0x00	; 0
 56a:	f0 e0       	ldi	r31, 0x00	; 0
 56c:	21 c0       	rjmp	.+66     	; 0x5b0 <_atoi+0xce>
        }
    }

    for (i = 0; i < StrLength; ++i)
	{
        if ((*buf >= 'a') && (*buf <= 'f'))
 56e:	d5 01       	movw	r26, r10
 570:	2d 91       	ld	r18, X+
 572:	5d 01       	movw	r10, r26
 574:	32 2f       	mov	r19, r18
 576:	31 56       	subi	r19, 0x61	; 97
 578:	82 2f       	mov	r24, r18
 57a:	90 e0       	ldi	r25, 0x00	; 0
 57c:	36 30       	cpi	r19, 0x06	; 6
 57e:	18 f4       	brcc	.+6      	; 0x586 <_atoi+0xa4>
        {   // lower-case ascii
            StrVal += ((*buf - 'a') + 10) * power;
 580:	87 55       	subi	r24, 0x57	; 87
 582:	90 40       	sbci	r25, 0x00	; 0
 584:	06 c0       	rjmp	.+12     	; 0x592 <_atoi+0xb0>
        }
        else if ((*buf >= 'A') && (*buf <= 'F'))
 586:	21 54       	subi	r18, 0x41	; 65
 588:	26 30       	cpi	r18, 0x06	; 6
 58a:	10 f4       	brcc	.+4      	; 0x590 <_atoi+0xae>
        {   // upper-case ascii
            StrVal += ((*buf - 'A') + 10) * power;
 58c:	c7 97       	sbiw	r24, 0x37	; 55
 58e:	01 c0       	rjmp	.+2      	; 0x592 <_atoi+0xb0>
        }
        else
        {
		    StrVal += (*buf - '0') * power;
 590:	c0 97       	sbiw	r24, 0x30	; 48
 592:	86 9f       	mul	r24, r22
 594:	90 01       	movw	r18, r0
 596:	87 9f       	mul	r24, r23
 598:	30 0d       	add	r19, r0
 59a:	96 9f       	mul	r25, r22
 59c:	30 0d       	add	r19, r0
 59e:	11 24       	eor	r1, r1
 5a0:	e2 0f       	add	r30, r18
 5a2:	f3 1f       	adc	r31, r19
        }

        // Move to next character. Reduce power by base
		++buf;
        power /= base;
 5a4:	cb 01       	movw	r24, r22
 5a6:	b7 01       	movw	r22, r14
 5a8:	0e 94 e2 06 	call	0xdc4	; 0xdc4 <__divmodhi4>
        {
            power *= 16;
        }
    }

    for (i = 0; i < StrLength; ++i)
 5ac:	0f 5f       	subi	r16, 0xFF	; 255
 5ae:	1f 4f       	sbci	r17, 0xFF	; 255
 5b0:	0c 17       	cp	r16, r28
 5b2:	1d 07       	cpc	r17, r29
 5b4:	e4 f2       	brlt	.-72     	; 0x56e <_atoi+0x8c>
        // Move to next character. Reduce power by base
		++buf;
        power /= base;
	}

    return negNum ? -StrVal : StrVal;
 5b6:	dd 20       	and	r13, r13
 5b8:	19 f0       	breq	.+6      	; 0x5c0 <_atoi+0xde>
 5ba:	f0 95       	com	r31
 5bc:	e1 95       	neg	r30
 5be:	ff 4f       	sbci	r31, 0xFF	; 255
}
 5c0:	cf 01       	movw	r24, r30
 5c2:	df 91       	pop	r29
 5c4:	cf 91       	pop	r28
 5c6:	1f 91       	pop	r17
 5c8:	0f 91       	pop	r16
 5ca:	ff 90       	pop	r15
 5cc:	ef 90       	pop	r14
 5ce:	df 90       	pop	r13
 5d0:	bf 90       	pop	r11
 5d2:	af 90       	pop	r10
 5d4:	08 95       	ret

000005d6 <heartbeat>:
/*********************** Function Implementations ******************************/

void heartbeat(void)
{
	// see warning about SET_BIT in lib.h
	asm volatile (" sbi	0x09, 0 ");
 5d6:	48 9a       	sbi	0x09, 0	; 9
}
 5d8:	08 95       	ret

000005da <GetStackByteCount>:
	
	int PatternCount = 0; // Counter to keep track of number of 0xAA's in a row
			
	unsigned char *stkPtr; // Pointer to pointer to current value in RAM
	
	unsigned char prevValue = 0; // used to store previous value
 5da:	40 e0       	ldi	r20, 0x00	; 0
	
	for (stkPtr=(unsigned char*)MAX_MEM_ADDR; stkPtr>=(unsigned char*)MIN_MEM_ADDR; stkPtr--) //Start stkPtr at top of RAM 0x21FF
 5dc:	ef ef       	ldi	r30, 0xFF	; 255
 5de:	f1 e2       	ldi	r31, 0x21	; 33
	 *       used at some point, and somehow, you didn't crash.
	 */
	
	int StackCount = 0; // Counter to keep track of total stack usage
	
	int PatternCount = 0; // Counter to keep track of number of 0xAA's in a row
 5e0:	20 e0       	ldi	r18, 0x00	; 0
 5e2:	30 e0       	ldi	r19, 0x00	; 0
	 *       a value in use happens to be 0xAA.
	 *    b) You get to the start of RAM at 0x200. Clearly, all RAM has been
	 *       used at some point, and somehow, you didn't crash.
	 */
	
	int StackCount = 0; // Counter to keep track of total stack usage
 5e4:	80 e0       	ldi	r24, 0x00	; 0
 5e6:	90 e0       	ldi	r25, 0x00	; 0
	
	unsigned char prevValue = 0; // used to store previous value
	
	for (stkPtr=(unsigned char*)MAX_MEM_ADDR; stkPtr>=(unsigned char*)MIN_MEM_ADDR; stkPtr--) //Start stkPtr at top of RAM 0x21FF
	{
		if(prevValue == RAM_PATTERN)	//check if previous value of SP is 0xAA
 5e8:	4a 3a       	cpi	r20, 0xAA	; 170
 5ea:	21 f4       	brne	.+8      	; 0x5f4 <GetStackByteCount+0x1a>
		{
			if (*stkPtr == RAM_PATTERN) //check if current value of SP is 0xAA. If so increase pattern count
 5ec:	40 81       	ld	r20, Z
 5ee:	4a 3a       	cpi	r20, 0xAA	; 170
 5f0:	39 f4       	brne	.+14     	; 0x600 <GetStackByteCount+0x26>
 5f2:	03 c0       	rjmp	.+6      	; 0x5fa <GetStackByteCount+0x20>
			else
				PatternCount=0;		// Reset pattern count back to zero if current value is not 0xAA				
		}
		else  //previous value is not 0xAA 
		{
			if (*stkPtr == RAM_PATTERN) // If current value is 0xAA increase pattern count
 5f4:	40 81       	ld	r20, Z
 5f6:	4a 3a       	cpi	r20, 0xAA	; 170
 5f8:	29 f4       	brne	.+10     	; 0x604 <GetStackByteCount+0x2a>
			PatternCount++;
 5fa:	2f 5f       	subi	r18, 0xFF	; 255
 5fc:	3f 4f       	sbci	r19, 0xFF	; 255
 5fe:	02 c0       	rjmp	.+4      	; 0x604 <GetStackByteCount+0x2a>
		if(prevValue == RAM_PATTERN)	//check if previous value of SP is 0xAA
		{
			if (*stkPtr == RAM_PATTERN) //check if current value of SP is 0xAA. If so increase pattern count
				PatternCount++;
			else
				PatternCount=0;		// Reset pattern count back to zero if current value is not 0xAA				
 600:	20 e0       	ldi	r18, 0x00	; 0
 602:	30 e0       	ldi	r19, 0x00	; 0
		{
			if (*stkPtr == RAM_PATTERN) // If current value is 0xAA increase pattern count
			PatternCount++;
		}		
				
		prevValue = *stkPtr; // Set current value to previous value
 604:	40 81       	ld	r20, Z
		StackCount++;	
		
		if (PatternCount == RAM_MIN_PATTERN) //check for 3 0xAA's in a row
 606:	23 30       	cpi	r18, 0x03	; 3
 608:	31 05       	cpc	r19, r1
 60a:	11 f4       	brne	.+4      	; 0x610 <GetStackByteCount+0x36>
			return StackCount-3; // Subtract off 0xAA's from count and return value
 60c:	02 97       	sbiw	r24, 0x02	; 2
 60e:	08 95       	ret
			if (*stkPtr == RAM_PATTERN) // If current value is 0xAA increase pattern count
			PatternCount++;
		}		
				
		prevValue = *stkPtr; // Set current value to previous value
		StackCount++;	
 610:	01 96       	adiw	r24, 0x01	; 1
			
	unsigned char *stkPtr; // Pointer to pointer to current value in RAM
	
	unsigned char prevValue = 0; // used to store previous value
	
	for (stkPtr=(unsigned char*)MAX_MEM_ADDR; stkPtr>=(unsigned char*)MIN_MEM_ADDR; stkPtr--) //Start stkPtr at top of RAM 0x21FF
 612:	31 97       	sbiw	r30, 0x01	; 1
 614:	51 e0       	ldi	r21, 0x01	; 1
 616:	ef 3f       	cpi	r30, 0xFF	; 255
 618:	f5 07       	cpc	r31, r21
 61a:	31 f7       	brne	.-52     	; 0x5e8 <GetStackByteCount+0xe>
		if (PatternCount == RAM_MIN_PATTERN) //check for 3 0xAA's in a row
			return StackCount-3; // Subtract off 0xAA's from count and return value
	}	
	return StackCount;

}
 61c:	08 95       	ret

0000061e <RunMenu>:
static DebugMenuStateType MenuState = TOP_MENU;

int DisplaySamples = 0;

void RunMenu(void)
{
 61e:	cf 92       	push	r12
 620:	df 92       	push	r13
 622:	ef 92       	push	r14
 624:	ff 92       	push	r15
 626:	0f 93       	push	r16
 628:	1f 93       	push	r17
 62a:	cf 93       	push	r28
 62c:	df 93       	push	r29
 62e:	cd b7       	in	r28, 0x3d	; 61
 630:	de b7       	in	r29, 0x3e	; 62
 632:	c6 54       	subi	r28, 0x46	; 70
 634:	d0 40       	sbci	r29, 0x00	; 0
 636:	0f b6       	in	r0, 0x3f	; 63
 638:	f8 94       	cli
 63a:	de bf       	out	0x3e, r29	; 62
 63c:	0f be       	out	0x3f, r0	; 63
 63e:	cd bf       	out	0x3d, r28	; 61
    while ((cTempChar = SCIReadChar()) != 0)
    {   // Have another character from input buffer
        if (cTempChar == '\r')
        {   // Enter character. Process input
            *ptrInputStr = '\0';        // append Null
            ptrInputStr = zInputStr;    // Reset input string
 640:	80 e5       	ldi	r24, 0x50	; 80
 642:	c8 2e       	mov	r12, r24
 644:	82 e0       	ldi	r24, 0x02	; 2
 646:	d8 2e       	mov	r13, r24
                                if ((i % 16) == 0)
                                {
                                    SCIWriteString_P(PSTR("\n\r  "));

                                    // Display address
                                    ptrOutputStr = zOutputStr;
 648:	93 e0       	ldi	r25, 0x03	; 3
 64a:	e9 2e       	mov	r14, r25
 64c:	f1 2c       	mov	r15, r1
 64e:	ec 0e       	add	r14, r28
 650:	fd 1e       	adc	r15, r29
    static DebugMenuSubType MenuAction = READ_MEMORY;
	static unsigned int i, Address = 0, Length = 0, Value = 0;
	int StackByteCount;

    // Read input characters until input buffer is empty
    while ((cTempChar = SCIReadChar()) != 0)
 652:	a6 c1       	rjmp	.+844    	; 0x9a0 <RunMenu+0x382>
 654:	e0 91 49 02 	lds	r30, 0x0249
 658:	f0 91 4a 02 	lds	r31, 0x024A
    {   // Have another character from input buffer
        if (cTempChar == '\r')
 65c:	8d 30       	cpi	r24, 0x0D	; 13
 65e:	09 f0       	breq	.+2      	; 0x662 <RunMenu+0x44>
 660:	8d c1       	rjmp	.+794    	; 0x97c <RunMenu+0x35e>
        {   // Enter character. Process input
            *ptrInputStr = '\0';        // append Null
 662:	10 82       	st	Z, r1
            ptrInputStr = zInputStr;    // Reset input string
 664:	d0 92 4a 02 	sts	0x024A, r13
 668:	c0 92 49 02 	sts	0x0249, r12
            SCIWriteString_P(PSTR("\n\r"));     // Move cursor to next line
 66c:	84 ee       	ldi	r24, 0xE4	; 228
 66e:	90 e0       	ldi	r25, 0x00	; 0
 670:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>

			// Reset displaying of A/D samples
            DisplaySamples = 0;
 674:	10 92 4f 02 	sts	0x024F, r1
 678:	10 92 4e 02 	sts	0x024E, r1

            // Process entry based on debug menu state
            switch(MenuState)
 67c:	80 91 5a 02 	lds	r24, 0x025A
 680:	87 30       	cpi	r24, 0x07	; 7
 682:	09 f4       	brne	.+2      	; 0x686 <RunMenu+0x68>
 684:	7b c0       	rjmp	.+246    	; 0x77c <RunMenu+0x15e>
 686:	88 30       	cpi	r24, 0x08	; 8
 688:	09 f4       	brne	.+2      	; 0x68c <RunMenu+0x6e>
 68a:	a2 c0       	rjmp	.+324    	; 0x7d0 <RunMenu+0x1b2>
 68c:	88 23       	and	r24, r24
 68e:	09 f0       	breq	.+2      	; 0x692 <RunMenu+0x74>
 690:	66 c1       	rjmp	.+716    	; 0x95e <RunMenu+0x340>
            {
                case TOP_MENU:
                    if (strcmp(zInputStr, "?") == 0)
 692:	80 e5       	ldi	r24, 0x50	; 80
 694:	92 e0       	ldi	r25, 0x02	; 2
 696:	69 e0       	ldi	r22, 0x09	; 9
 698:	72 e0       	ldi	r23, 0x02	; 2
 69a:	0e 94 f5 06 	call	0xdea	; 0xdea <strcmp>
 69e:	00 97       	sbiw	r24, 0x00	; 0
 6a0:	11 f4       	brne	.+4      	; 0x6a6 <RunMenu+0x88>
                    {   // Help screen
						MenuState = DISPLAY_HELP_MENU1;
 6a2:	81 e0       	ldi	r24, 0x01	; 1
 6a4:	92 c0       	rjmp	.+292    	; 0x7ca <RunMenu+0x1ac>
                    }

                    else if (strcmp(zInputStr, "ge") == 0)
 6a6:	80 e5       	ldi	r24, 0x50	; 80
 6a8:	92 e0       	ldi	r25, 0x02	; 2
 6aa:	6b e0       	ldi	r22, 0x0B	; 11
 6ac:	72 e0       	ldi	r23, 0x02	; 2
 6ae:	0e 94 f5 06 	call	0xdea	; 0xdea <strcmp>
 6b2:	00 97       	sbiw	r24, 0x00	; 0
 6b4:	e1 f4       	brne	.+56     	; 0x6ee <RunMenu+0xd0>
                    {   // Display desired signal parameters
                        // Retrieve signal parameters
                        error = GetError();
 6b6:	0e 94 70 01 	call	0x2e0	; 0x2e0 <GetError>
 6ba:	68 2f       	mov	r22, r24
                        SCIWriteString_P(PSTR("  Error = "));
 6bc:	87 ee       	ldi	r24, 0xE7	; 231
 6be:	90 e0       	ldi	r25, 0x00	; 0
 6c0:	27 96       	adiw	r28, 0x07	; 7
 6c2:	6f af       	sts	0x7f, r22
 6c4:	27 97       	sbiw	r28, 0x07	; 7
 6c6:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
                        ptrOutputStr = zOutputStr;
 6ca:	fa 82       	std	Y+2, r15	; 0x02
 6cc:	e9 82       	std	Y+1, r14	; 0x01
                        _itoa(&ptrOutputStr, error, 10);
 6ce:	ce 01       	movw	r24, r28
 6d0:	01 96       	adiw	r24, 0x01	; 1
 6d2:	27 96       	adiw	r28, 0x07	; 7
 6d4:	6f ad       	sts	0x6f, r22
 6d6:	27 97       	sbiw	r28, 0x07	; 7
 6d8:	70 e0       	ldi	r23, 0x00	; 0
 6da:	4a e0       	ldi	r20, 0x0A	; 10
 6dc:	50 e0       	ldi	r21, 0x00	; 0
 6de:	0e 94 ff 01 	call	0x3fe	; 0x3fe <_itoa>
                        SCIWriteString(zOutputStr);
 6e2:	c7 01       	movw	r24, r14
 6e4:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>
                        SCIWriteString_P(PSTR("\n\r"));
 6e8:	82 ef       	ldi	r24, 0xF2	; 242
 6ea:	90 e0       	ldi	r25, 0x00	; 0
 6ec:	5f c0       	rjmp	.+190    	; 0x7ac <RunMenu+0x18e>
                    }

                    else if (strcmp(zInputStr, "ce") == 0)
 6ee:	80 e5       	ldi	r24, 0x50	; 80
 6f0:	92 e0       	ldi	r25, 0x02	; 2
 6f2:	6e e0       	ldi	r22, 0x0E	; 14
 6f4:	72 e0       	ldi	r23, 0x02	; 2
 6f6:	0e 94 f5 06 	call	0xdea	; 0xdea <strcmp>
 6fa:	00 97       	sbiw	r24, 0x00	; 0
 6fc:	19 f4       	brne	.+6      	; 0x704 <RunMenu+0xe6>
                    {
                        ClearError();
 6fe:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <ClearError>
 702:	2f c1       	rjmp	.+606    	; 0x962 <RunMenu+0x344>
                    }

					else if ((strcmp(zInputStr, "rm") == 0) ||
 704:	80 e5       	ldi	r24, 0x50	; 80
 706:	92 e0       	ldi	r25, 0x02	; 2
 708:	61 e1       	ldi	r22, 0x11	; 17
 70a:	72 e0       	ldi	r23, 0x02	; 2
 70c:	0e 94 f5 06 	call	0xdea	; 0xdea <strcmp>
 710:	00 97       	sbiw	r24, 0x00	; 0
 712:	49 f0       	breq	.+18     	; 0x726 <RunMenu+0x108>
                             (strcmp(zInputStr, "wm") == 0))
 714:	80 e5       	ldi	r24, 0x50	; 80
 716:	92 e0       	ldi	r25, 0x02	; 2
 718:	64 e1       	ldi	r22, 0x14	; 20
 71a:	72 e0       	ldi	r23, 0x02	; 2
 71c:	0e 94 f5 06 	call	0xdea	; 0xdea <strcmp>
                    else if (strcmp(zInputStr, "ce") == 0)
                    {
                        ClearError();
                    }

					else if ((strcmp(zInputStr, "rm") == 0) ||
 720:	00 97       	sbiw	r24, 0x00	; 0
 722:	21 f0       	breq	.+8      	; 0x72c <RunMenu+0x10e>
 724:	0c c0       	rjmp	.+24     	; 0x73e <RunMenu+0x120>
                             (strcmp(zInputStr, "wm") == 0))
                    {   // Memory menu
                        if (strcmp(zInputStr, "rm") == 0)
                        {
                            MenuAction = READ_MEMORY;
 726:	10 92 5b 02 	sts	0x025B, r1
 72a:	03 c0       	rjmp	.+6      	; 0x732 <RunMenu+0x114>
                        }
                        else
                        {
                            MenuAction = WRITE_MEMORY;
 72c:	81 e0       	ldi	r24, 0x01	; 1
 72e:	80 93 5b 02 	sts	0x025B, r24
                        }

                        // Get address
                        SCIWriteString("  Starting address in hex (200 to 21FF) = ");
 732:	87 e1       	ldi	r24, 0x17	; 23
 734:	92 e0       	ldi	r25, 0x02	; 2
 736:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>
                        MenuState = MEMORY_GET_ADDRESS;
 73a:	87 e0       	ldi	r24, 0x07	; 7
 73c:	46 c0       	rjmp	.+140    	; 0x7ca <RunMenu+0x1ac>
                    }

					else if (strcmp(zInputStr, "sk") == 0) 
 73e:	80 e5       	ldi	r24, 0x50	; 80
 740:	92 e0       	ldi	r25, 0x02	; 2
 742:	62 e4       	ldi	r22, 0x42	; 66
 744:	72 e0       	ldi	r23, 0x02	; 2
 746:	0e 94 f5 06 	call	0xdea	; 0xdea <strcmp>
 74a:	00 97       	sbiw	r24, 0x00	; 0
 74c:	09 f0       	breq	.+2      	; 0x750 <RunMenu+0x132>
 74e:	07 c1       	rjmp	.+526    	; 0x95e <RunMenu+0x340>
					{
						StackByteCount = GetStackByteCount();
 750:	0e 94 ed 02 	call	0x5da	; 0x5da <GetStackByteCount>
 754:	8c 01       	movw	r16, r24
                        SCIWriteString_P(PSTR("Stack Byte Count = "));
 756:	85 ef       	ldi	r24, 0xF5	; 245
 758:	90 e0       	ldi	r25, 0x00	; 0
 75a:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
                        ptrOutputStr = zOutputStr;
 75e:	fa 82       	std	Y+2, r15	; 0x02
 760:	e9 82       	std	Y+1, r14	; 0x01
                        _itoa(&ptrOutputStr, StackByteCount, 10);
 762:	ce 01       	movw	r24, r28
 764:	01 96       	adiw	r24, 0x01	; 1
 766:	b8 01       	movw	r22, r16
 768:	4a e0       	ldi	r20, 0x0A	; 10
 76a:	50 e0       	ldi	r21, 0x00	; 0
 76c:	0e 94 ff 01 	call	0x3fe	; 0x3fe <_itoa>
                        SCIWriteString(zOutputStr);
 770:	c7 01       	movw	r24, r14
 772:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>
                        SCIWriteString_P(PSTR("\n\r"));
 776:	89 e0       	ldi	r24, 0x09	; 9
 778:	91 e0       	ldi	r25, 0x01	; 1
 77a:	18 c0       	rjmp	.+48     	; 0x7ac <RunMenu+0x18e>
                        MenuState = TOP_MENU;
                    }
                    break;

				case MEMORY_GET_ADDRESS:
                    if (zInputStr[0] != '\0')
 77c:	80 91 50 02 	lds	r24, 0x0250
 780:	88 23       	and	r24, r24
 782:	09 f4       	brne	.+2      	; 0x786 <RunMenu+0x168>
 784:	ec c0       	rjmp	.+472    	; 0x95e <RunMenu+0x340>
                    {   // Just skip NULL entries
                        Address = _atoi(zInputStr, 16);
 786:	80 e5       	ldi	r24, 0x50	; 80
 788:	92 e0       	ldi	r25, 0x02	; 2
 78a:	60 e1       	ldi	r22, 0x10	; 16
 78c:	70 e0       	ldi	r23, 0x00	; 0
 78e:	0e 94 71 02 	call	0x4e2	; 0x4e2 <_atoi>
 792:	9c 01       	movw	r18, r24
 794:	90 93 5d 02 	sts	0x025D, r25
 798:	80 93 5c 02 	sts	0x025C, r24
						
						if ((Address < MIN_MEM_ADDR) ||
 79c:	20 50       	subi	r18, 0x00	; 0
 79e:	32 40       	sbci	r19, 0x02	; 2
 7a0:	80 e2       	ldi	r24, 0x20	; 32
 7a2:	20 30       	cpi	r18, 0x00	; 0
 7a4:	38 07       	cpc	r19, r24
 7a6:	28 f0       	brcs	.+10     	; 0x7b2 <RunMenu+0x194>
						    (Address > MAX_MEM_ADDR))
						{	// Address out of range
							SCIWriteString_P(PSTR("  Address out of range\n\r"));
 7a8:	8c e0       	ldi	r24, 0x0C	; 12
 7aa:	91 e0       	ldi	r25, 0x01	; 1
 7ac:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
 7b0:	d8 c0       	rjmp	.+432    	; 0x962 <RunMenu+0x344>
						}
						else
						{
							if (MenuAction == READ_MEMORY)
 7b2:	80 91 5b 02 	lds	r24, 0x025B
 7b6:	88 23       	and	r24, r24
 7b8:	19 f4       	brne	.+6      	; 0x7c0 <RunMenu+0x1a2>
							{
								// Now get length
								SCIWriteString_P(PSTR("  Length in hex (max 40) = "));
 7ba:	85 e2       	ldi	r24, 0x25	; 37
 7bc:	91 e0       	ldi	r25, 0x01	; 1
 7be:	02 c0       	rjmp	.+4      	; 0x7c4 <RunMenu+0x1a6>
							}
							else
							{
								SCIWriteString_P(PSTR("  Value (in hex) = "));
 7c0:	81 e4       	ldi	r24, 0x41	; 65
 7c2:	91 e0       	ldi	r25, 0x01	; 1
 7c4:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
							}
							MenuState = MEMORY_GET_LENGTH;
 7c8:	88 e0       	ldi	r24, 0x08	; 8
 7ca:	80 93 5a 02 	sts	0x025A, r24
 7ce:	c9 c0       	rjmp	.+402    	; 0x962 <RunMenu+0x344>
						MenuState = TOP_MENU;
					}
                    break;

               case MEMORY_GET_LENGTH:
                    if (zInputStr[0] != '\0')
 7d0:	80 91 50 02 	lds	r24, 0x0250
 7d4:	88 23       	and	r24, r24
 7d6:	09 f4       	brne	.+2      	; 0x7da <RunMenu+0x1bc>
 7d8:	c4 c0       	rjmp	.+392    	; 0x962 <RunMenu+0x344>
                    {
                        if (MenuAction == READ_MEMORY)
 7da:	80 91 5b 02 	lds	r24, 0x025B
 7de:	88 23       	and	r24, r24
 7e0:	09 f0       	breq	.+2      	; 0x7e4 <RunMenu+0x1c6>
 7e2:	9b c0       	rjmp	.+310    	; 0x91a <RunMenu+0x2fc>
                        {
                            Length = _atoi(zInputStr, 16);
 7e4:	80 e5       	ldi	r24, 0x50	; 80
 7e6:	92 e0       	ldi	r25, 0x02	; 2
 7e8:	60 e1       	ldi	r22, 0x10	; 16
 7ea:	70 e0       	ldi	r23, 0x00	; 0
 7ec:	0e 94 71 02 	call	0x4e2	; 0x4e2 <_atoi>
 7f0:	9c 01       	movw	r18, r24
 7f2:	90 93 5f 02 	sts	0x025F, r25
 7f6:	80 93 5e 02 	sts	0x025E, r24
							
							// Limit memory to available RAM
							if ((Address + Length - 1) > MAX_MEM_ADDR)
 7fa:	40 91 5c 02 	lds	r20, 0x025C
 7fe:	50 91 5d 02 	lds	r21, 0x025D
 802:	ca 01       	movw	r24, r20
 804:	01 97       	sbiw	r24, 0x01	; 1
 806:	82 0f       	add	r24, r18
 808:	93 1f       	adc	r25, r19
 80a:	22 e2       	ldi	r18, 0x22	; 34
 80c:	80 30       	cpi	r24, 0x00	; 0
 80e:	92 07       	cpc	r25, r18
 810:	40 f0       	brcs	.+16     	; 0x822 <RunMenu+0x204>
							{
								Length = MAX_MEM_ADDR - Address + 1;
 812:	80 e0       	ldi	r24, 0x00	; 0
 814:	92 e2       	ldi	r25, 0x22	; 34
 816:	84 1b       	sub	r24, r20
 818:	95 0b       	sbc	r25, r21
 81a:	90 93 5f 02 	sts	0x025F, r25
 81e:	80 93 5e 02 	sts	0x025E, r24
							}
							
                            if (Length == 0)
 822:	80 91 5e 02 	lds	r24, 0x025E
 826:	90 91 5f 02 	lds	r25, 0x025F
 82a:	00 97       	sbiw	r24, 0x00	; 0
 82c:	31 f4       	brne	.+12     	; 0x83a <RunMenu+0x21c>
                            {   // default to 1
                                Length = 1;
 82e:	81 e0       	ldi	r24, 0x01	; 1
 830:	90 e0       	ldi	r25, 0x00	; 0
 832:	90 93 5f 02 	sts	0x025F, r25
 836:	80 93 5e 02 	sts	0x025E, r24
                            }

                            if (Length > MAX_MEM_SIZE)
 83a:	80 91 5e 02 	lds	r24, 0x025E
 83e:	90 91 5f 02 	lds	r25, 0x025F
 842:	81 34       	cpi	r24, 0x41	; 65
 844:	91 05       	cpc	r25, r1
 846:	30 f0       	brcs	.+12     	; 0x854 <RunMenu+0x236>
                            {
                                Length = MAX_MEM_SIZE;
 848:	80 e4       	ldi	r24, 0x40	; 64
 84a:	90 e0       	ldi	r25, 0x00	; 0
 84c:	90 93 5f 02 	sts	0x025F, r25
 850:	80 93 5e 02 	sts	0x025E, r24
                            }

                            SCIWriteString_P(PSTR("  Memory ="));
 854:	85 e5       	ldi	r24, 0x55	; 85
 856:	91 e0       	ldi	r25, 0x01	; 1
 858:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>

                            for (i = 0; i < Length; ++i)
 85c:	10 92 61 02 	sts	0x0261, r1
 860:	10 92 60 02 	sts	0x0260, r1

                                // Force to be 2 characters long
                                if (strlen(zOutputStr) < 2)
                                {
                                    zOutputStr[1] = zOutputStr[0];
                                    zOutputStr[0]= '0';
 864:	00 e3       	ldi	r16, 0x30	; 48
                                }
                                zOutputStr[2] = ' ';
 866:	10 e2       	ldi	r17, 0x20	; 32
                                Length = MAX_MEM_SIZE;
                            }

                            SCIWriteString_P(PSTR("  Memory ="));

                            for (i = 0; i < Length; ++i)
 868:	49 c0       	rjmp	.+146    	; 0x8fc <RunMenu+0x2de>
                            {
                                if ((i % 16) == 0)
 86a:	8f 70       	andi	r24, 0x0F	; 15
 86c:	90 70       	andi	r25, 0x00	; 0
 86e:	00 97       	sbiw	r24, 0x00	; 0
 870:	b9 f4       	brne	.+46     	; 0x8a0 <RunMenu+0x282>
                                {
                                    SCIWriteString_P(PSTR("\n\r  "));
 872:	80 e6       	ldi	r24, 0x60	; 96
 874:	91 e0       	ldi	r25, 0x01	; 1
 876:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>

                                    // Display address
                                    ptrOutputStr = zOutputStr;
 87a:	fa 82       	std	Y+2, r15	; 0x02
 87c:	e9 82       	std	Y+1, r14	; 0x01
                                    _itoa(&ptrOutputStr, Address, 16);
 87e:	60 91 5c 02 	lds	r22, 0x025C
 882:	70 91 5d 02 	lds	r23, 0x025D
 886:	ce 01       	movw	r24, r28
 888:	01 96       	adiw	r24, 0x01	; 1
 88a:	40 e1       	ldi	r20, 0x10	; 16
 88c:	50 e0       	ldi	r21, 0x00	; 0
 88e:	0e 94 ff 01 	call	0x3fe	; 0x3fe <_itoa>
                                    SCIWriteString(zOutputStr);
 892:	c7 01       	movw	r24, r14
 894:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>
                                    SCIWriteString(">  ");
 898:	85 e4       	ldi	r24, 0x45	; 69
 89a:	92 e0       	ldi	r25, 0x02	; 2
 89c:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>
                                }

                                ptrOutputStr = zOutputStr;
 8a0:	fa 82       	std	Y+2, r15	; 0x02
 8a2:	e9 82       	std	Y+1, r14	; 0x01
                                *ptrOutputStr = *(unsigned char *)Address;
 8a4:	e0 91 5c 02 	lds	r30, 0x025C
 8a8:	f0 91 5d 02 	lds	r31, 0x025D
 8ac:	61 91       	ld	r22, Z+
 8ae:	6b 83       	std	Y+3, r22	; 0x03
                                ++Address;
 8b0:	f0 93 5d 02 	sts	0x025D, r31
 8b4:	e0 93 5c 02 	sts	0x025C, r30

                                // Convert character to an ASCII string in Hex
                                _itoa(&ptrOutputStr, (int)zOutputStr[0], 16);
 8b8:	ce 01       	movw	r24, r28
 8ba:	01 96       	adiw	r24, 0x01	; 1
 8bc:	70 e0       	ldi	r23, 0x00	; 0
 8be:	40 e1       	ldi	r20, 0x10	; 16
 8c0:	50 e0       	ldi	r21, 0x00	; 0
 8c2:	0e 94 ff 01 	call	0x3fe	; 0x3fe <_itoa>

                                // Force to be 2 characters long
                                if (strlen(zOutputStr) < 2)
 8c6:	f7 01       	movw	r30, r14
 8c8:	01 90       	ld	r0, Z+
 8ca:	00 20       	and	r0, r0
 8cc:	e9 f7       	brne	.-6      	; 0x8c8 <RunMenu+0x2aa>
 8ce:	31 97       	sbiw	r30, 0x01	; 1
 8d0:	ee 19       	sub	r30, r14
 8d2:	ff 09       	sbc	r31, r15
 8d4:	e2 30       	cpi	r30, 0x02	; 2
 8d6:	f1 05       	cpc	r31, r1
 8d8:	18 f4       	brcc	.+6      	; 0x8e0 <RunMenu+0x2c2>
                                {
                                    zOutputStr[1] = zOutputStr[0];
 8da:	8b 81       	ldd	r24, Y+3	; 0x03
 8dc:	8c 83       	std	Y+4, r24	; 0x04
                                    zOutputStr[0]= '0';
 8de:	0b 83       	std	Y+3, r16	; 0x03
                                }
                                zOutputStr[2] = ' ';
 8e0:	1d 83       	std	Y+5, r17	; 0x05
                                zOutputStr[3] = '\0';
 8e2:	1e 82       	std	Y+6, r1	; 0x06
                                SCIWriteString(zOutputStr);
 8e4:	c7 01       	movw	r24, r14
 8e6:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>
                                Length = MAX_MEM_SIZE;
                            }

                            SCIWriteString_P(PSTR("  Memory ="));

                            for (i = 0; i < Length; ++i)
 8ea:	80 91 60 02 	lds	r24, 0x0260
 8ee:	90 91 61 02 	lds	r25, 0x0261
 8f2:	01 96       	adiw	r24, 0x01	; 1
 8f4:	90 93 61 02 	sts	0x0261, r25
 8f8:	80 93 60 02 	sts	0x0260, r24
 8fc:	80 91 60 02 	lds	r24, 0x0260
 900:	90 91 61 02 	lds	r25, 0x0261
 904:	20 91 5e 02 	lds	r18, 0x025E
 908:	30 91 5f 02 	lds	r19, 0x025F
 90c:	82 17       	cp	r24, r18
 90e:	93 07       	cpc	r25, r19
 910:	08 f4       	brcc	.+2      	; 0x914 <RunMenu+0x2f6>
 912:	ab cf       	rjmp	.-170    	; 0x86a <RunMenu+0x24c>
                                zOutputStr[2] = ' ';
                                zOutputStr[3] = '\0';
                                SCIWriteString(zOutputStr);
                            }

                            SCIWriteString_P(PSTR("\n\r"));
 914:	85 e6       	ldi	r24, 0x65	; 101
 916:	91 e0       	ldi	r25, 0x01	; 1
 918:	20 c0       	rjmp	.+64     	; 0x95a <RunMenu+0x33c>
                        }
                        else
                        {   // Write memory
                            Value = _atoi(zInputStr, 16);
 91a:	80 e5       	ldi	r24, 0x50	; 80
 91c:	92 e0       	ldi	r25, 0x02	; 2
 91e:	60 e1       	ldi	r22, 0x10	; 16
 920:	70 e0       	ldi	r23, 0x00	; 0
 922:	0e 94 71 02 	call	0x4e2	; 0x4e2 <_atoi>
 926:	90 93 63 02 	sts	0x0263, r25
 92a:	80 93 62 02 	sts	0x0262, r24

                            if (Value > 0xFF)
 92e:	8f 3f       	cpi	r24, 0xFF	; 255
 930:	91 05       	cpc	r25, r1
 932:	21 f0       	breq	.+8      	; 0x93c <RunMenu+0x31e>
 934:	18 f0       	brcs	.+6      	; 0x93c <RunMenu+0x31e>
                            {   // invalid value
                                SCIWriteString_P(PSTR("Invalid value\n\r"));
 936:	88 e6       	ldi	r24, 0x68	; 104
 938:	91 e0       	ldi	r25, 0x01	; 1
 93a:	0f c0       	rjmp	.+30     	; 0x95a <RunMenu+0x33c>
                                MenuState = TOP_MENU;
                            }
                            else
                            {
                                SCIWriteString_P(PSTR("Write Mem\n\r"));
 93c:	88 e7       	ldi	r24, 0x78	; 120
 93e:	91 e0       	ldi	r25, 0x01	; 1
 940:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
                                ptrOutputStr = (char *)Address;
 944:	e0 91 5c 02 	lds	r30, 0x025C
 948:	f0 91 5d 02 	lds	r31, 0x025D
 94c:	fa 83       	std	Y+2, r31	; 0x02
 94e:	e9 83       	std	Y+1, r30	; 0x01
                                *ptrOutputStr = (char)Value;
 950:	80 91 62 02 	lds	r24, 0x0262
 954:	80 83       	st	Z, r24

                                SCIWriteString_P(PSTR("\n\r"));
 956:	84 e8       	ldi	r24, 0x84	; 132
 958:	91 e0       	ldi	r25, 0x01	; 1
 95a:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
					
                    break;

				default:
                    // Erroneus state. Reset to none
                    MenuState = TOP_MENU;
 95e:	10 92 5a 02 	sts	0x025A, r1
                    break;
            }   // end switch

            // Reset string pointer. May have been moved during command processing
            ptrInputStr = zInputStr;
 962:	d0 92 4a 02 	sts	0x024A, r13
 966:	c0 92 49 02 	sts	0x0249, r12

            if (MenuState == TOP_MENU)
 96a:	80 91 5a 02 	lds	r24, 0x025A
 96e:	88 23       	and	r24, r24
 970:	b9 f4       	brne	.+46     	; 0x9a0 <RunMenu+0x382>
            {
                // Display prompt
                SCIWriteString_P(PSTR("cmd> "));
 972:	87 e8       	ldi	r24, 0x87	; 135
 974:	91 e0       	ldi	r25, 0x01	; 1
 976:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
 97a:	12 c0       	rjmp	.+36     	; 0x9a0 <RunMenu+0x382>
            }
        }
        else
        {   // Save new character to input buffer
            if (ptrInputStr < &zInputStr[MAX_IN_STR_SIZE-2])
 97c:	92 e0       	ldi	r25, 0x02	; 2
 97e:	e8 35       	cpi	r30, 0x58	; 88
 980:	f9 07       	cpc	r31, r25
 982:	70 f4       	brcc	.+28     	; 0x9a0 <RunMenu+0x382>
            {   // Buffer is not full
                *ptrInputStr = cTempChar;
 984:	80 83       	st	Z, r24
                *(ptrInputStr+1) = '\0';    // Keep null in string
 986:	11 82       	std	Z+1, r1	; 0x01

                // echo character
                SCIWriteString(ptrInputStr);
 988:	cf 01       	movw	r24, r30
 98a:	0e 94 d3 05 	call	0xba6	; 0xba6 <SCIWriteString>

                ++ptrInputStr;
 98e:	80 91 49 02 	lds	r24, 0x0249
 992:	90 91 4a 02 	lds	r25, 0x024A
 996:	01 96       	adiw	r24, 0x01	; 1
 998:	90 93 4a 02 	sts	0x024A, r25
 99c:	80 93 49 02 	sts	0x0249, r24
    static DebugMenuSubType MenuAction = READ_MEMORY;
	static unsigned int i, Address = 0, Length = 0, Value = 0;
	int StackByteCount;

    // Read input characters until input buffer is empty
    while ((cTempChar = SCIReadChar()) != 0)
 9a0:	0e 94 9a 06 	call	0xd34	; 0xd34 <SCIReadChar>
 9a4:	88 23       	and	r24, r24
 9a6:	09 f0       	breq	.+2      	; 0x9aa <RunMenu+0x38c>
 9a8:	55 ce       	rjmp	.-854    	; 0x654 <RunMenu+0x36>
                ++ptrInputStr;
            }   // else, buffer is full. Ignore characters.
        }
    }   // End while. All characters processed

	if (MenuState == DISPLAY_HELP_MENU1)
 9aa:	80 91 5a 02 	lds	r24, 0x025A
 9ae:	81 30       	cpi	r24, 0x01	; 1
 9b0:	51 f4       	brne	.+20     	; 0x9c6 <RunMenu+0x3a8>
	{	// Display 1st part of help menu
		SCIWriteString_P(PSTR("  Commands are:\n\r"));
 9b2:	8d e8       	ldi	r24, 0x8D	; 141
 9b4:	91 e0       	ldi	r25, 0x01	; 1
 9b6:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		SCIWriteString_P(PSTR("  ge  - Display error code\n\r"));
 9ba:	8f e9       	ldi	r24, 0x9F	; 159
 9bc:	91 e0       	ldi	r25, 0x01	; 1
 9be:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		MenuState = DISPLAY_HELP_MENU2;
 9c2:	82 e0       	ldi	r24, 0x02	; 2
 9c4:	07 c0       	rjmp	.+14     	; 0x9d4 <RunMenu+0x3b6>
	}
	
	else if (MenuState == DISPLAY_HELP_MENU2)
 9c6:	82 30       	cpi	r24, 0x02	; 2
 9c8:	41 f4       	brne	.+16     	; 0x9da <RunMenu+0x3bc>
	{	// Display 2nd part of help menu
		SCIWriteString_P(PSTR("  ce  - Clear current error\n\r"));
 9ca:	8c eb       	ldi	r24, 0xBC	; 188
 9cc:	91 e0       	ldi	r25, 0x01	; 1
 9ce:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		MenuState = DISPLAY_HELP_MENU3;
 9d2:	83 e0       	ldi	r24, 0x03	; 3
 9d4:	80 93 5a 02 	sts	0x025A, r24
 9d8:	20 c0       	rjmp	.+64     	; 0xa1a <RunMenu+0x3fc>
	}
	
	else if (MenuState == DISPLAY_HELP_MENU3)
 9da:	83 30       	cpi	r24, 0x03	; 3
 9dc:	31 f4       	brne	.+12     	; 0x9ea <RunMenu+0x3cc>
	{	// Display 3rd part of help menu
		SCIWriteString_P(PSTR("  sk  - stack used\n\r"));		
 9de:	8a ed       	ldi	r24, 0xDA	; 218
 9e0:	91 e0       	ldi	r25, 0x01	; 1
 9e2:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		MenuState = DISPLAY_HELP_MENU4;
 9e6:	84 e0       	ldi	r24, 0x04	; 4
 9e8:	f5 cf       	rjmp	.-22     	; 0x9d4 <RunMenu+0x3b6>
	}

	else if (MenuState == DISPLAY_HELP_MENU4)
 9ea:	84 30       	cpi	r24, 0x04	; 4
 9ec:	11 f4       	brne	.+4      	; 0x9f2 <RunMenu+0x3d4>
	{	// Display 4th part of help menu - not used here
		MenuState = DISPLAY_HELP_MENU5;
 9ee:	85 e0       	ldi	r24, 0x05	; 5
 9f0:	f1 cf       	rjmp	.-30     	; 0x9d4 <RunMenu+0x3b6>
	}

	else if (MenuState == DISPLAY_HELP_MENU5)
 9f2:	85 30       	cpi	r24, 0x05	; 5
 9f4:	31 f4       	brne	.+12     	; 0xa02 <RunMenu+0x3e4>
	{	// Display 5th part of help menu
		SCIWriteString_P(PSTR("  rm  - Read memory\n\r"));
 9f6:	8f ee       	ldi	r24, 0xEF	; 239
 9f8:	91 e0       	ldi	r25, 0x01	; 1
 9fa:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		MenuState = DISPLAY_HELP_MENU6;
 9fe:	86 e0       	ldi	r24, 0x06	; 6
 a00:	e9 cf       	rjmp	.-46     	; 0x9d4 <RunMenu+0x3b6>
	}

	else if (MenuState == DISPLAY_HELP_MENU6)
 a02:	86 30       	cpi	r24, 0x06	; 6
 a04:	51 f4       	brne	.+20     	; 0xa1a <RunMenu+0x3fc>
	{	// Display 6th part of help menu
		SCIWriteString_P(PSTR("  wm  - Write memory\n\r"));
 a06:	85 e0       	ldi	r24, 0x05	; 5
 a08:	92 e0       	ldi	r25, 0x02	; 2
 a0a:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		SCIWriteString_P(PSTR("  ?   - Display this help menu\n\r"));
 a0e:	8c e1       	ldi	r24, 0x1C	; 28
 a10:	92 e0       	ldi	r25, 0x02	; 2
 a12:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
		MenuState = TOP_MENU;
 a16:	10 92 5a 02 	sts	0x025A, r1
	}
}
 a1a:	ca 5b       	subi	r28, 0xBA	; 186
 a1c:	df 4f       	sbci	r29, 0xFF	; 255
 a1e:	0f b6       	in	r0, 0x3f	; 63
 a20:	f8 94       	cli
 a22:	de bf       	out	0x3e, r29	; 62
 a24:	0f be       	out	0x3f, r0	; 63
 a26:	cd bf       	out	0x3d, r28	; 61
 a28:	df 91       	pop	r29
 a2a:	cf 91       	pop	r28
 a2c:	1f 91       	pop	r17
 a2e:	0f 91       	pop	r16
 a30:	ff 90       	pop	r15
 a32:	ef 90       	pop	r14
 a34:	df 90       	pop	r13
 a36:	cf 90       	pop	r12
 a38:	08 95       	ret

00000a3a <__vector_26>:
 * Interrupt Handler for Transmitting data
 * Leave interrupts disabled during this ISR so we don't interrupt ourselves,
 * bypassing our checks.
 *****************************************************************************/
ISR(USART0_UDRE_vect)
{
 a3a:	1f 92       	push	r1
 a3c:	0f 92       	push	r0
 a3e:	0f b6       	in	r0, 0x3f	; 63
 a40:	0f 92       	push	r0
 a42:	0b b6       	in	r0, 0x3b	; 59
 a44:	0f 92       	push	r0
 a46:	11 24       	eor	r1, r1
 a48:	2f 93       	push	r18
 a4a:	3f 93       	push	r19
 a4c:	8f 93       	push	r24
 a4e:	9f 93       	push	r25
 a50:	ef 93       	push	r30
 a52:	ff 93       	push	r31
	char TxData;
	    
	// Disable UDR interrupt, and enable global interrupts
	CLEAR_BIT(UCSR0B, UDRIE0);
 a54:	80 91 c1 00 	lds	r24, 0x00C1
 a58:	8f 7d       	andi	r24, 0xDF	; 223
 a5a:	80 93 c1 00 	sts	0x00C1, r24
	sei();
 a5e:	78 94       	sei

	// Save value to transmit, so we can send it later in the ISR.
	TxData = *ptrOutputCharTail;
 a60:	e0 91 68 02 	lds	r30, 0x0268
 a64:	f0 91 69 02 	lds	r31, 0x0269
 a68:	20 81       	ld	r18, Z

	/* Move pointer to next character */            
	ptrOutputCharTail = INC_CIRC_BUFFER_PTR(ptrOutputCharTail, 
 a6a:	80 91 68 02 	lds	r24, 0x0268
 a6e:	90 91 69 02 	lds	r25, 0x0269
 a72:	33 e0       	ldi	r19, 0x03	; 3
 a74:	8f 36       	cpi	r24, 0x6F	; 111
 a76:	93 07       	cpc	r25, r19
 a78:	30 f4       	brcc	.+12     	; 0xa86 <__vector_26+0x4c>
 a7a:	80 91 68 02 	lds	r24, 0x0268
 a7e:	90 91 69 02 	lds	r25, 0x0269
 a82:	01 96       	adiw	r24, 0x01	; 1
 a84:	02 c0       	rjmp	.+4      	; 0xa8a <__vector_26+0x50>
 a86:	86 e7       	ldi	r24, 0x76	; 118
 a88:	92 e0       	ldi	r25, 0x02	; 2
 a8a:	90 93 69 02 	sts	0x0269, r25
 a8e:	80 93 68 02 	sts	0x0268, r24
						zOutputChars, MAX_OUT_STR_SIZE);

	// Send next character. We do this as close to the end of the ISR as
	// possible.
    UDR0 = TxData;
 a92:	20 93 c6 00 	sts	0x00C6, r18

	/* Check to see if we've just transmitted the last character.
	 * If not, enable the interrupt. */
	if (ptrOutputCharTail != ptrOutputCharHead)        
 a96:	20 91 68 02 	lds	r18, 0x0268
 a9a:	30 91 69 02 	lds	r19, 0x0269
 a9e:	80 91 6a 02 	lds	r24, 0x026A
 aa2:	90 91 6b 02 	lds	r25, 0x026B
 aa6:	28 17       	cp	r18, r24
 aa8:	39 07       	cpc	r19, r25
 aaa:	29 f0       	breq	.+10     	; 0xab6 <__vector_26+0x7c>
	{
		SET_BIT(UCSR0B, UDRIE0);
 aac:	80 91 c1 00 	lds	r24, 0x00C1
 ab0:	80 62       	ori	r24, 0x20	; 32
 ab2:	80 93 c1 00 	sts	0x00C1, r24
	}
}
 ab6:	ff 91       	pop	r31
 ab8:	ef 91       	pop	r30
 aba:	9f 91       	pop	r25
 abc:	8f 91       	pop	r24
 abe:	3f 91       	pop	r19
 ac0:	2f 91       	pop	r18
 ac2:	0f 90       	pop	r0
 ac4:	0b be       	out	0x3b, r0	; 59
 ac6:	0f 90       	pop	r0
 ac8:	0f be       	out	0x3f, r0	; 63
 aca:	0f 90       	pop	r0
 acc:	1f 90       	pop	r1
 ace:	18 95       	reti

00000ad0 <__vector_25>:

/*****************************************************************************
 * Interrupt Handler for Receiving data
 *****************************************************************************/
ISR(USART0_RX_vect)
{
 ad0:	1f 92       	push	r1
 ad2:	0f 92       	push	r0
 ad4:	0f b6       	in	r0, 0x3f	; 63
 ad6:	0f 92       	push	r0
 ad8:	0b b6       	in	r0, 0x3b	; 59
 ada:	0f 92       	push	r0
 adc:	11 24       	eor	r1, r1
 ade:	2f 93       	push	r18
 ae0:	3f 93       	push	r19
 ae2:	4f 93       	push	r20
 ae4:	5f 93       	push	r21
 ae6:	6f 93       	push	r22
 ae8:	7f 93       	push	r23
 aea:	8f 93       	push	r24
 aec:	9f 93       	push	r25
 aee:	af 93       	push	r26
 af0:	bf 93       	push	r27
 af2:	cf 93       	push	r28
 af4:	ef 93       	push	r30
 af6:	ff 93       	push	r31
	unsigned char status;
	char *ptrPrev;
   
	/* must do this first, since reading UDR0 resets the error flags */
	status = UCSR0A;
 af8:	c0 91 c0 00 	lds	r28, 0x00C0
   
	/* Append character to input string */
	*ptrInputCharHead = UDR0;
 afc:	e0 91 66 02 	lds	r30, 0x0266
 b00:	f0 91 67 02 	lds	r31, 0x0267
 b04:	80 91 c6 00 	lds	r24, 0x00C6
 b08:	80 83       	st	Z, r24

   /* Move pointer to next character */
	ptrPrev = ptrInputCharHead;
 b0a:	80 91 66 02 	lds	r24, 0x0266
 b0e:	90 91 67 02 	lds	r25, 0x0267
	ptrInputCharHead = INC_CIRC_BUFFER_PTR(ptrInputCharHead, zInputChars, 
 b12:	20 91 66 02 	lds	r18, 0x0266
 b16:	30 91 67 02 	lds	r19, 0x0267
 b1a:	42 e0       	ldi	r20, 0x02	; 2
 b1c:	25 37       	cpi	r18, 0x75	; 117
 b1e:	34 07       	cpc	r19, r20
 b20:	38 f4       	brcc	.+14     	; 0xb30 <__vector_25+0x60>
 b22:	20 91 66 02 	lds	r18, 0x0266
 b26:	30 91 67 02 	lds	r19, 0x0267
 b2a:	2f 5f       	subi	r18, 0xFF	; 255
 b2c:	3f 4f       	sbci	r19, 0xFF	; 255
 b2e:	02 c0       	rjmp	.+4      	; 0xb34 <__vector_25+0x64>
 b30:	2c e6       	ldi	r18, 0x6C	; 108
 b32:	32 e0       	ldi	r19, 0x02	; 2
 b34:	30 93 67 02 	sts	0x0267, r19
 b38:	20 93 66 02 	sts	0x0266, r18
										   MAX_IN_STR_SIZE);

	/* Check for receive buffer overflow */
	if (ptrInputCharHead == ptrInputCharTail)
 b3c:	40 91 66 02 	lds	r20, 0x0266
 b40:	50 91 67 02 	lds	r21, 0x0267
 b44:	20 91 64 02 	lds	r18, 0x0264
 b48:	30 91 65 02 	lds	r19, 0x0265
 b4c:	42 17       	cp	r20, r18
 b4e:	53 07       	cpc	r21, r19
 b50:	39 f4       	brne	.+14     	; 0xb60 <__vector_25+0x90>
	{  /* Buffer is full. By incrementing the pointer, it actually looks
		* empty. So, decrement by 1, throwing away last received character,
		* and record the problem.
		*/
		ptrInputCharHead = ptrPrev;
 b52:	90 93 67 02 	sts	0x0267, r25
 b56:	80 93 66 02 	sts	0x0266, r24
		ReportError(SCI_RX_BUFFER_OVERFLOW);
 b5a:	84 e0       	ldi	r24, 0x04	; 4
 b5c:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
	}

	/* Check for input character errors */
   
	if ((status & _BV(FE0)) != 0)
 b60:	c4 ff       	sbrs	r28, 4
 b62:	03 c0       	rjmp	.+6      	; 0xb6a <__vector_25+0x9a>
	{
		ReportError(SCI_RX_FRAME);
 b64:	86 e0       	ldi	r24, 0x06	; 6
 b66:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
	}

	if ((status & _BV(DOR0)) != 0)
 b6a:	c3 ff       	sbrs	r28, 3
 b6c:	03 c0       	rjmp	.+6      	; 0xb74 <__vector_25+0xa4>
	{
		ReportError(SCI_RX_DATA_OVERRUN);
 b6e:	87 e0       	ldi	r24, 0x07	; 7
 b70:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
	}

	if ((status & _BV(UPE0)) != 0)
 b74:	c2 ff       	sbrs	r28, 2
 b76:	03 c0       	rjmp	.+6      	; 0xb7e <__vector_25+0xae>
	{
		ReportError(SCI_RX_PARITY);
 b78:	88 e0       	ldi	r24, 0x08	; 8
 b7a:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
	}
}
 b7e:	ff 91       	pop	r31
 b80:	ef 91       	pop	r30
 b82:	cf 91       	pop	r28
 b84:	bf 91       	pop	r27
 b86:	af 91       	pop	r26
 b88:	9f 91       	pop	r25
 b8a:	8f 91       	pop	r24
 b8c:	7f 91       	pop	r23
 b8e:	6f 91       	pop	r22
 b90:	5f 91       	pop	r21
 b92:	4f 91       	pop	r20
 b94:	3f 91       	pop	r19
 b96:	2f 91       	pop	r18
 b98:	0f 90       	pop	r0
 b9a:	0b be       	out	0x3b, r0	; 59
 b9c:	0f 90       	pop	r0
 b9e:	0f be       	out	0x3f, r0	; 63
 ba0:	0f 90       	pop	r0
 ba2:	1f 90       	pop	r1
 ba4:	18 95       	reti

00000ba6 <SCIWriteString>:
{
    int iReturnCode = 0;    /* Assume success */
    eBooleanType bCopyComplete = FALSE;

    /* Check to see if transmit buffer is full */
    while ((INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 ba6:	1f c0       	rjmp	.+62     	; 0xbe6 <SCIWriteString+0x40>
			    				zOutputChars,
				    			MAX_OUT_STR_SIZE) != ptrOutputCharTail) &&
           (bCopyComplete == FALSE))

	{   /* Copy string to transmit to the output buffer */
        if (*Str != '\0')
 ba8:	fc 01       	movw	r30, r24
 baa:	20 81       	ld	r18, Z
 bac:	22 23       	and	r18, r18
 bae:	e9 f0       	breq	.+58     	; 0xbea <SCIWriteString+0x44>
        {
            *ptrOutputCharHead = *Str;
 bb0:	e0 91 6a 02 	lds	r30, 0x026A
 bb4:	f0 91 6b 02 	lds	r31, 0x026B
 bb8:	20 83       	st	Z, r18
 
            /* Move pointer to next character */
  		    ptrOutputCharHead = INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 bba:	20 91 6a 02 	lds	r18, 0x026A
 bbe:	30 91 6b 02 	lds	r19, 0x026B
 bc2:	f3 e0       	ldi	r31, 0x03	; 3
 bc4:	2f 36       	cpi	r18, 0x6F	; 111
 bc6:	3f 07       	cpc	r19, r31
 bc8:	38 f4       	brcc	.+14     	; 0xbd8 <SCIWriteString+0x32>
 bca:	20 91 6a 02 	lds	r18, 0x026A
 bce:	30 91 6b 02 	lds	r19, 0x026B
 bd2:	2f 5f       	subi	r18, 0xFF	; 255
 bd4:	3f 4f       	sbci	r19, 0xFF	; 255
 bd6:	02 c0       	rjmp	.+4      	; 0xbdc <SCIWriteString+0x36>
 bd8:	26 e7       	ldi	r18, 0x76	; 118
 bda:	32 e0       	ldi	r19, 0x02	; 2
 bdc:	30 93 6b 02 	sts	0x026B, r19
 be0:	20 93 6a 02 	sts	0x026A, r18
			    								    zOutputChars,
				    							    MAX_OUT_STR_SIZE);
            ++Str;
 be4:	01 96       	adiw	r24, 0x01	; 1
        if (*Str != '\0')
        {
            *ptrOutputCharHead = *Str;
 
            /* Move pointer to next character */
  		    ptrOutputCharHead = INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 be6:	60 e0       	ldi	r22, 0x00	; 0
 be8:	01 c0       	rjmp	.+2      	; 0xbec <SCIWriteString+0x46>
				    							    MAX_OUT_STR_SIZE);
            ++Str;
        }
        else
        {   /* Done copying characters */
            bCopyComplete = TRUE;
 bea:	61 e0       	ldi	r22, 0x01	; 1
{
    int iReturnCode = 0;    /* Assume success */
    eBooleanType bCopyComplete = FALSE;

    /* Check to see if transmit buffer is full */
    while ((INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 bec:	20 91 6a 02 	lds	r18, 0x026A
 bf0:	30 91 6b 02 	lds	r19, 0x026B
 bf4:	43 e0       	ldi	r20, 0x03	; 3
 bf6:	2f 36       	cpi	r18, 0x6F	; 111
 bf8:	34 07       	cpc	r19, r20
 bfa:	38 f4       	brcc	.+14     	; 0xc0a <SCIWriteString+0x64>
 bfc:	20 91 6a 02 	lds	r18, 0x026A
 c00:	30 91 6b 02 	lds	r19, 0x026B
 c04:	2f 5f       	subi	r18, 0xFF	; 255
 c06:	3f 4f       	sbci	r19, 0xFF	; 255
 c08:	02 c0       	rjmp	.+4      	; 0xc0e <SCIWriteString+0x68>
 c0a:	26 e7       	ldi	r18, 0x76	; 118
 c0c:	32 e0       	ldi	r19, 0x02	; 2
			    				zOutputChars,
				    			MAX_OUT_STR_SIZE) != ptrOutputCharTail) &&
 c0e:	40 91 68 02 	lds	r20, 0x0268
 c12:	50 91 69 02 	lds	r21, 0x0269
{
    int iReturnCode = 0;    /* Assume success */
    eBooleanType bCopyComplete = FALSE;

    /* Check to see if transmit buffer is full */
    while ((INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 c16:	24 17       	cp	r18, r20
 c18:	35 07       	cpc	r19, r21
 c1a:	19 f0       	breq	.+6      	; 0xc22 <SCIWriteString+0x7c>
			    				zOutputChars,
				    			MAX_OUT_STR_SIZE) != ptrOutputCharTail) &&
 c1c:	66 23       	and	r22, r22
 c1e:	21 f2       	breq	.-120    	; 0xba8 <SCIWriteString+0x2>
 c20:	61 e0       	ldi	r22, 0x01	; 1
            bCopyComplete = TRUE;
        }
    }   /* end of copying string */

    /* Enable transmitter interrupt */
	SET_BIT(UCSR0B, UDRIE0);
 c22:	80 91 c1 00 	lds	r24, 0x00C1
 c26:	80 62       	ori	r24, 0x20	; 32
 c28:	80 93 c1 00 	sts	0x00C1, r24

    /* See if the reason we stopped copying the string was because the 
     * buffer was full. Note that the buffer being full may no longer be the
     * case, even if it was true when copying, so we have to use our complete
     * flag. */
    if (bCopyComplete == FALSE)
 c2c:	66 23       	and	r22, r22
 c2e:	31 f4       	brne	.+12     	; 0xc3c <SCIWriteString+0x96>
    {   /* Prematurely terminated copying */
        ReportError(SCI_TX_BUFFER_OVERFLOW);
 c30:	85 e0       	ldi	r24, 0x05	; 5
 c32:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
        iReturnCode = -1;
 c36:	8f ef       	ldi	r24, 0xFF	; 255
 c38:	9f ef       	ldi	r25, 0xFF	; 255
 c3a:	08 95       	ret
/******************************************************************************
 * Outputs the specified string to the RS-232 port.
 ******************************************************************************/
int SCIWriteString(char *Str)
{
    int iReturnCode = 0;    /* Assume success */
 c3c:	80 e0       	ldi	r24, 0x00	; 0
 c3e:	90 e0       	ldi	r25, 0x00	; 0
        ReportError(SCI_TX_BUFFER_OVERFLOW);
        iReturnCode = -1;
    }

    return iReturnCode;
}
 c40:	08 95       	ret

00000c42 <SCIWriteString_P>:
	
			//while (!(UCSR0A & (1 << UDRE0)));
			//UDR0 = 0x33;
	
    /* Check to see if transmit buffer is full */
    while ((INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 c42:	1d c0       	rjmp	.+58     	; 0xc7e <SCIWriteString_P+0x3c>
           (bCopyComplete == FALSE))

	{   /* Copy string to transmit to the output buffer */
					
		Char_P = pgm_read_byte(Str_P);
        if (Char_P != '\0')
 c44:	77 23       	and	r23, r23
 c46:	f9 f0       	breq	.+62     	; 0xc86 <SCIWriteString_P+0x44>
        {
            *ptrOutputCharHead = Char_P;
 c48:	e0 91 6a 02 	lds	r30, 0x026A
 c4c:	f0 91 6b 02 	lds	r31, 0x026B
 c50:	70 83       	st	Z, r23
 
            /* Move pointer to next character */
  		    ptrOutputCharHead = INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 c52:	20 91 6a 02 	lds	r18, 0x026A
 c56:	30 91 6b 02 	lds	r19, 0x026B
 c5a:	43 e0       	ldi	r20, 0x03	; 3
 c5c:	2f 36       	cpi	r18, 0x6F	; 111
 c5e:	34 07       	cpc	r19, r20
 c60:	38 f4       	brcc	.+14     	; 0xc70 <SCIWriteString_P+0x2e>
 c62:	20 91 6a 02 	lds	r18, 0x026A
 c66:	30 91 6b 02 	lds	r19, 0x026B
 c6a:	2f 5f       	subi	r18, 0xFF	; 255
 c6c:	3f 4f       	sbci	r19, 0xFF	; 255
 c6e:	02 c0       	rjmp	.+4      	; 0xc74 <SCIWriteString_P+0x32>
 c70:	26 e7       	ldi	r18, 0x76	; 118
 c72:	32 e0       	ldi	r19, 0x02	; 2
 c74:	30 93 6b 02 	sts	0x026B, r19
 c78:	20 93 6a 02 	sts	0x026A, r18
			    								    zOutputChars,
				    							    MAX_OUT_STR_SIZE);
            ++Str_P;
 c7c:	01 96       	adiw	r24, 0x01	; 1
        if (Char_P != '\0')
        {
            *ptrOutputCharHead = Char_P;
 
            /* Move pointer to next character */
  		    ptrOutputCharHead = INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 c7e:	60 e0       	ldi	r22, 0x00	; 0
				    			MAX_OUT_STR_SIZE) != ptrOutputCharTail) &&
           (bCopyComplete == FALSE))

	{   /* Copy string to transmit to the output buffer */
					
		Char_P = pgm_read_byte(Str_P);
 c80:	fc 01       	movw	r30, r24
 c82:	74 91       	lpm	r23, Z
 c84:	01 c0       	rjmp	.+2      	; 0xc88 <SCIWriteString_P+0x46>
				    							    MAX_OUT_STR_SIZE);
            ++Str_P;
        }
        else
        {   /* Done copying characters */
            bCopyComplete = TRUE;
 c86:	61 e0       	ldi	r22, 0x01	; 1
	
			//while (!(UCSR0A & (1 << UDRE0)));
			//UDR0 = 0x33;
	
    /* Check to see if transmit buffer is full */
    while ((INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 c88:	20 91 6a 02 	lds	r18, 0x026A
 c8c:	30 91 6b 02 	lds	r19, 0x026B
 c90:	f3 e0       	ldi	r31, 0x03	; 3
 c92:	2f 36       	cpi	r18, 0x6F	; 111
 c94:	3f 07       	cpc	r19, r31
 c96:	38 f4       	brcc	.+14     	; 0xca6 <SCIWriteString_P+0x64>
 c98:	20 91 6a 02 	lds	r18, 0x026A
 c9c:	30 91 6b 02 	lds	r19, 0x026B
 ca0:	2f 5f       	subi	r18, 0xFF	; 255
 ca2:	3f 4f       	sbci	r19, 0xFF	; 255
 ca4:	02 c0       	rjmp	.+4      	; 0xcaa <SCIWriteString_P+0x68>
 ca6:	26 e7       	ldi	r18, 0x76	; 118
 ca8:	32 e0       	ldi	r19, 0x02	; 2
			    				zOutputChars,
				    			MAX_OUT_STR_SIZE) != ptrOutputCharTail) &&
 caa:	40 91 68 02 	lds	r20, 0x0268
 cae:	50 91 69 02 	lds	r21, 0x0269
	
			//while (!(UCSR0A & (1 << UDRE0)));
			//UDR0 = 0x33;
	
    /* Check to see if transmit buffer is full */
    while ((INC_CIRC_BUFFER_PTR(ptrOutputCharHead, 
 cb2:	24 17       	cp	r18, r20
 cb4:	35 07       	cpc	r19, r21
 cb6:	19 f0       	breq	.+6      	; 0xcbe <SCIWriteString_P+0x7c>
			    				zOutputChars,
				    			MAX_OUT_STR_SIZE) != ptrOutputCharTail) &&
 cb8:	66 23       	and	r22, r22
 cba:	21 f2       	breq	.-120    	; 0xc44 <SCIWriteString_P+0x2>
 cbc:	61 e0       	ldi	r22, 0x01	; 1
            bCopyComplete = TRUE;
        }
    }   /* end of copying string */

    /* Enable transmitter interrupt */
	SET_BIT(UCSR0B, UDRIE0);
 cbe:	80 91 c1 00 	lds	r24, 0x00C1
 cc2:	80 62       	ori	r24, 0x20	; 32
 cc4:	80 93 c1 00 	sts	0x00C1, r24

    /* See if the reason we stopped copying the string was because the 
     * buffer was full. Note that the buffer being full may no longer be the
     * case, even if it was true when copying, so we have to use our complete
     * flag. */
    if (bCopyComplete == FALSE)
 cc8:	66 23       	and	r22, r22
 cca:	31 f4       	brne	.+12     	; 0xcd8 <SCIWriteString_P+0x96>
    {   /* Prematurely terminated copying */
        ReportError(SCI_TX_BUFFER_OVERFLOW);
 ccc:	85 e0       	ldi	r24, 0x05	; 5
 cce:	0e 94 64 01 	call	0x2c8	; 0x2c8 <ReportError>
        iReturnCode = -1;
 cd2:	8f ef       	ldi	r24, 0xFF	; 255
 cd4:	9f ef       	ldi	r25, 0xFF	; 255
 cd6:	08 95       	ret
/******************************************************************************
 * Outputs the specified string, stored in program space, to the RS-232 port.
 ******************************************************************************/
int SCIWriteString_P(PGM_P Str_P)
{
    int iReturnCode = 0;    /* Assume success */
 cd8:	80 e0       	ldi	r24, 0x00	; 0
 cda:	90 e0       	ldi	r25, 0x00	; 0
        ReportError(SCI_TX_BUFFER_OVERFLOW);
        iReturnCode = -1;
    }

    return iReturnCode;
}
 cdc:	08 95       	ret

00000cde <SCIInitialize>:
 * Initialize the SCI interface.
 ******************************************************************************/
void SCIInitialize(void)
{
	// Set the baud rate 
	UBRR0 = UBRR_VALUE;
 cde:	8f ec       	ldi	r24, 0xCF	; 207
 ce0:	90 e0       	ldi	r25, 0x00	; 0
 ce2:	90 93 c5 00 	sts	0x00C5, r25
 ce6:	80 93 c4 00 	sts	0x00C4, r24
	 *       3: USBS0   = 0  1 stop bit
	 *       2: UCSZ01  = 1, 8 data bits 
	 *       1: UCSZ00  = 1
	 *       0: UCPOL   = 0, Not used for asynchronous mode
	 */
	UCSR0C  = _BV(UCSZ01) | _BV(UCSZ00);
 cea:	86 e0       	ldi	r24, 0x06	; 6
 cec:	80 93 c2 00 	sts	0x00C2, r24
	 *       3: TXEN0  = 1, Transmitter enabled
	 *       2: UCSZ02 = 0, 8 data bits (see UCSR0C)
	 *       1: RXB80  = 0, Read-only bit
	 *       0: TXB80  = 0, No 9th data bit
	 */
	UCSR0B = _BV(RXCIE0) | _BV(RXEN0) | _BV(TXEN0);
 cf0:	88 e9       	ldi	r24, 0x98	; 152
 cf2:	80 93 c1 00 	sts	0x00C1, r24
	 *       3: DOR0  = 0, Read-only bit
	 *       2: UPE0  = 0, Read-only bit
	 *       1: U2X0  = 0, Do not want to double TX rate
	 *       0: MPCM0 = 0, No multi-processor mode
	 */
	UCSR0A = 0;
 cf6:	10 92 c0 00 	sts	0x00C0, r1

   /* Initialize the pointers to the character buffers. New characters to be
     * received or transmitted are  added using the Head pointer. When characters
     * retrieved by an outside program or transmitted by the transmitter, they're
     * removed from the buffers using the Tail pointer. */
    ptrInputCharHead    = zInputChars;
 cfa:	8c e6       	ldi	r24, 0x6C	; 108
 cfc:	92 e0       	ldi	r25, 0x02	; 2
 cfe:	90 93 67 02 	sts	0x0267, r25
 d02:	80 93 66 02 	sts	0x0266, r24
    ptrInputCharTail    = zInputChars;
 d06:	90 93 65 02 	sts	0x0265, r25
 d0a:	80 93 64 02 	sts	0x0264, r24
    ptrOutputCharHead   = zOutputChars;
 d0e:	86 e7       	ldi	r24, 0x76	; 118
 d10:	92 e0       	ldi	r25, 0x02	; 2
 d12:	90 93 6b 02 	sts	0x026B, r25
 d16:	80 93 6a 02 	sts	0x026A, r24
    ptrOutputCharTail   = zOutputChars;
 d1a:	90 93 69 02 	sts	0x0269, r25
 d1e:	80 93 68 02 	sts	0x0268, r24

    // Display start-up greeting
    SCIWriteString_P(PSTR("Welcome to Embedded Systems Programming\n\r"));
 d22:	8d e3       	ldi	r24, 0x3D	; 61
 d24:	92 e0       	ldi	r25, 0x02	; 2
 d26:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
	SCIWriteString_P(PSTR("cmd> "));
 d2a:	87 e6       	ldi	r24, 0x67	; 103
 d2c:	92 e0       	ldi	r25, 0x02	; 2
 d2e:	0e 94 21 06 	call	0xc42	; 0xc42 <SCIWriteString_P>
}
 d32:	08 95       	ret

00000d34 <SCIReadChar>:
 ******************************************************************************/
char SCIReadChar(void)
{
   char cReturnVal;

   if (ptrInputCharHead != ptrInputCharTail)
 d34:	20 91 66 02 	lds	r18, 0x0266
 d38:	30 91 67 02 	lds	r19, 0x0267
 d3c:	80 91 64 02 	lds	r24, 0x0264
 d40:	90 91 65 02 	lds	r25, 0x0265
 d44:	28 17       	cp	r18, r24
 d46:	39 07       	cpc	r19, r25
 d48:	d9 f0       	breq	.+54     	; 0xd80 <SCIReadChar+0x4c>
   {   /* Receive buffer is not empty */
      cReturnVal = *ptrInputCharTail;
 d4a:	e0 91 64 02 	lds	r30, 0x0264
 d4e:	f0 91 65 02 	lds	r31, 0x0265
 d52:	80 81       	ld	r24, Z

      /* Move pointer to next character */
		ptrInputCharTail = INC_CIRC_BUFFER_PTR(ptrInputCharTail, 
 d54:	20 91 64 02 	lds	r18, 0x0264
 d58:	30 91 65 02 	lds	r19, 0x0265
 d5c:	92 e0       	ldi	r25, 0x02	; 2
 d5e:	25 37       	cpi	r18, 0x75	; 117
 d60:	39 07       	cpc	r19, r25
 d62:	38 f4       	brcc	.+14     	; 0xd72 <SCIReadChar+0x3e>
 d64:	20 91 64 02 	lds	r18, 0x0264
 d68:	30 91 65 02 	lds	r19, 0x0265
 d6c:	2f 5f       	subi	r18, 0xFF	; 255
 d6e:	3f 4f       	sbci	r19, 0xFF	; 255
 d70:	02 c0       	rjmp	.+4      	; 0xd76 <SCIReadChar+0x42>
 d72:	2c e6       	ldi	r18, 0x6C	; 108
 d74:	32 e0       	ldi	r19, 0x02	; 2
 d76:	30 93 65 02 	sts	0x0265, r19
 d7a:	20 93 64 02 	sts	0x0264, r18
 d7e:	08 95       	ret
											   zInputChars,
											   MAX_IN_STR_SIZE);
   }
   else
   {
      cReturnVal = 0;
 d80:	80 e0       	ldi	r24, 0x00	; 0
   }
   return cReturnVal;
}
 d82:	08 95       	ret

00000d84 <main>:
 * 
 *****************************************************************************/
int main(void) 
{
    // Disable interrupts
    cli();
 d84:	f8 94       	cli

	// Set port D as an output and turn off all LEDs
	DDRD = 0xFF;
 d86:	8f ef       	ldi	r24, 0xFF	; 255
 d88:	8a b9       	out	0x0a, r24	; 10
	PORTD = 0xFF;
 d8a:	8b b9       	out	0x0b, r24	; 11

    /* Initialize the Timer 0 */
    ISR_InitTimer0();
 d8c:	0e 94 73 01 	call	0x2e6	; 0x2e6 <ISR_InitTimer0>

	// Initialize serial I/O
	SCIInitialize();
 d90:	0e 94 6f 06 	call	0xcde	; 0xcde <SCIInitialize>
	
	GetStackByteCount();
 d94:	0e 94 ed 02 	call	0x5da	; 0x5da <GetStackByteCount>

    /* Enable interrupts. Do as last initialization, so interrupts are
     * not initiated until all of initialization is complete. */
   sei();
 d98:	78 94       	sei
 d9a:	ff cf       	rjmp	.-2      	; 0xd9a <main+0x16>

00000d9c <__udivmodhi4>:
 d9c:	aa 1b       	sub	r26, r26
 d9e:	bb 1b       	sub	r27, r27
 da0:	51 e1       	ldi	r21, 0x11	; 17
 da2:	07 c0       	rjmp	.+14     	; 0xdb2 <__udivmodhi4_ep>

00000da4 <__udivmodhi4_loop>:
 da4:	aa 1f       	adc	r26, r26
 da6:	bb 1f       	adc	r27, r27
 da8:	a6 17       	cp	r26, r22
 daa:	b7 07       	cpc	r27, r23
 dac:	10 f0       	brcs	.+4      	; 0xdb2 <__udivmodhi4_ep>
 dae:	a6 1b       	sub	r26, r22
 db0:	b7 0b       	sbc	r27, r23

00000db2 <__udivmodhi4_ep>:
 db2:	88 1f       	adc	r24, r24
 db4:	99 1f       	adc	r25, r25
 db6:	5a 95       	dec	r21
 db8:	a9 f7       	brne	.-22     	; 0xda4 <__udivmodhi4_loop>
 dba:	80 95       	com	r24
 dbc:	90 95       	com	r25
 dbe:	bc 01       	movw	r22, r24
 dc0:	cd 01       	movw	r24, r26
 dc2:	08 95       	ret

00000dc4 <__divmodhi4>:
 dc4:	97 fb       	bst	r25, 7
 dc6:	09 2e       	mov	r0, r25
 dc8:	07 26       	eor	r0, r23
 dca:	0a d0       	rcall	.+20     	; 0xde0 <__divmodhi4_neg1>
 dcc:	77 fd       	sbrc	r23, 7
 dce:	04 d0       	rcall	.+8      	; 0xdd8 <__divmodhi4_neg2>
 dd0:	e5 df       	rcall	.-54     	; 0xd9c <__udivmodhi4>
 dd2:	06 d0       	rcall	.+12     	; 0xde0 <__divmodhi4_neg1>
 dd4:	00 20       	and	r0, r0
 dd6:	1a f4       	brpl	.+6      	; 0xdde <__divmodhi4_exit>

00000dd8 <__divmodhi4_neg2>:
 dd8:	70 95       	com	r23
 dda:	61 95       	neg	r22
 ddc:	7f 4f       	sbci	r23, 0xFF	; 255

00000dde <__divmodhi4_exit>:
 dde:	08 95       	ret

00000de0 <__divmodhi4_neg1>:
 de0:	f6 f7       	brtc	.-4      	; 0xdde <__divmodhi4_exit>
 de2:	90 95       	com	r25
 de4:	81 95       	neg	r24
 de6:	9f 4f       	sbci	r25, 0xFF	; 255
 de8:	08 95       	ret

00000dea <strcmp>:
 dea:	fb 01       	movw	r30, r22
 dec:	dc 01       	movw	r26, r24
 dee:	8d 91       	ld	r24, X+
 df0:	01 90       	ld	r0, Z+
 df2:	80 19       	sub	r24, r0
 df4:	01 10       	cpse	r0, r1
 df6:	d9 f3       	breq	.-10     	; 0xdee <strcmp+0x4>
 df8:	99 0b       	sbc	r25, r25
 dfa:	08 95       	ret

00000dfc <_exit>:
 dfc:	f8 94       	cli

00000dfe <__stop_program>:
 dfe:	ff cf       	rjmp	.-2      	; 0xdfe <__stop_program>
